## 从url输入到页面呈现经历了什么？

- 网络请求部分
- 浏览器解析部分

## 说一说重绘和回流

## 😊 说一说垃圾回收

### 为什么存在垃圾回收？

V8引擎存在内存的限制。在64位系统上V8最多分配1.4g内存。JS的对象会保存到堆内存上，V8会为每一个对象分配空间，直到堆的大小到达上限。由于JS是单线程的，在进行垃圾回收期间，其他的活动需要暂停。而垃圾回收又是非常耗时的操作，所以V8会限制内存的大小，避免需要回收大量的内存。
### 垃圾回收的策略

1. 标记清理。所有变量都会在内存中被标记。垃圾回收程序会将，所有在当前上下文中的变量，以及被在当前上下文中的变量引用的变量的标记去掉。之后还被标记的变量就是待回收的了。随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存。

2. 引用计数。引用计数会遇到循环引用的问题，导致引用记数永远不会为0。Netscape在4.0版放弃了引用计数的策略。（策略已弃用）

### 新生代 & 老生代

![image.png](https://i.loli.net/2021/04/28/nzq8Aj1csNgPkTm.png)
#### 新生代

新生代，为临时分配的内存。新生代内存在64为系统下，为32mb。新生代内存分为`Form`和`To`两部分。垃圾回收会检查`Form`，没有被回收的变量会被移动到`To`，而需要清理的直接清理。接着`Form`和`To`会对调，`Form`变为`To`, `To`变为`Form`。然后下次垃圾回收时重复上面的步骤。

> 为什么不直接清除新生代中的内存呢？清理后会产生内存碎片🧩。需要使用上面的步骤，重新排列内存。
#### 老生代

老生代，为常驻内存。如果新生代中的变量如果经过多次回收后依然存在，那么就会被放入到老生代内存中。老生代的内存使用标记清理。（上面有介绍过程👆），标记清理后，V8会对内存空间重排。
### 垃圾回收的优化

1. 如果变量不在使用，可以主动将其设置为null。这被称为解除引用。
2. 使用let和const。因为它们都是块作用域，所以相比于使用var，会更早地让垃圾回收程序介入，尽早回收应该回收的内存。
3. 避免全局变量的使用
4. 避免闭包的过度使用
5. 即时不使用的清理定时器
6. 隐藏类。比如两个变量是同一个类的实例。如果额外的对其中的一个增加属性或者删除属性，将会导致实例不再共享一个隐藏类。

## 浏览器的架构

## 浏览器的工作原理


## 浏览器有哪些进程？渲染进程中有哪些线程？

## from memory cache 与 from disk cache

## 渲染合成层
