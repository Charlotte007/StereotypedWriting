## 😊 从url输入到页面呈现经历了什么？

1. URL解析，并构造HTTP请求，包含请求头，请求体。
2. 匹配缓存
    1. 根据请求的头的`expires`和`cache-control`判断是否命中强缓存策略。如果命中，直接从缓存获取资源，并不会发送请求。如果没有命中，则进入下一步。
    2. 没有命中强缓存，根据请求头的`last-modified`和`etag`判断是否命中协商缓存。如果命中，直接从缓存获取资源。如果没有命中，则进入下一步。
3. DNS解析：在发起HTTP请求之前，如果URL不是IP地址是域名，浏览器会发送一个UDP的包给DNS域名解析服务器。将域名解析为IP地址。DNS服务器本身也有IP，电脑的网络设置包含DNS服务器的IP。而DNS的解析分为递归查询和迭代查询。
    - DNS解析的具体流程，请看http章节。
4. 排队，Chrome在同一个域名下要求最多只能有6个TCP连接，超过6个就必须等待。
5. 建立TCP连接，通过"三次握手"与服务器建立TCP连接
6. TLS，TLS握手 （HTTPS需要7次握手，3次TCP握手，4次TLS握手）
    - TLS握手，用来传递公钥，对称密钥，以及传输确认加密传递的信息。（TLS的流程请看http章节）
7. 发送HTTP报文，
    - 包含了：请求行，请求头，空格，请求体（具体的组成请看http章节）
8. 服务器处理请求
9. 服务器响应HTTP请求
    - 包含了：响应行，响应头，空格，响应体（具体的组成请看http章节）
    - 响应完成之后，这时候需要判断请求头或者响应头中的Connection字段是否为`keep-alive`, 如果设置了`keep-alive`则保持这次TCP连接，等待下一次HTTP使用。否则发生四次挥手，断开TCP连接。
10. 浏览器解析，呈现页面

## 浏览器渲染流程
## 说一说重绘和回流

## 😊 说一说垃圾回收

### 为什么存在垃圾回收？

V8引擎存在内存的限制。在64位系统上V8最多分配1.4g内存。JS的对象会保存到堆内存上，V8会为每一个对象分配空间，直到堆的大小到达上限。由于JS是单线程的，在进行垃圾回收期间，其他的活动需要暂停。而垃圾回收又是非常耗时的操作，所以V8会限制内存的大小，避免需要回收大量的内存。
### 垃圾回收的策略

1. 标记清理。所有变量都会在内存中被标记。垃圾回收程序会将，所有在当前上下文中的变量，以及被在当前上下文中的变量引用的变量的标记去掉。之后还被标记的变量就是待回收的了。随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存。

2. 引用计数。引用计数会遇到循环引用的问题，导致引用记数永远不会为0。Netscape在4.0版放弃了引用计数的策略。（策略已弃用）

### 新生代 & 老生代

![image.png](https://i.loli.net/2021/04/28/nzq8Aj1csNgPkTm.png)
#### 新生代

新生代，为临时分配的内存。新生代内存在64为系统下，为32mb。新生代内存分为`Form`和`To`两部分。垃圾回收会检查`Form`，没有被回收的变量会被移动到`To`，而需要清理的直接清理。接着`Form`和`To`会对调，`Form`变为`To`, `To`变为`Form`。然后下次垃圾回收时重复上面的步骤。

> 为什么不直接清除新生代中的内存呢？清理后会产生内存碎片🧩。需要使用上面的步骤，重新排列内存。
#### 老生代

老生代，为常驻内存。如果新生代中的变量如果经过多次回收后依然存在，那么就会被放入到老生代内存中。老生代的内存使用标记清理。（上面有介绍过程👆），标记清理后，V8会对内存空间重排。
### 垃圾回收的优化

1. 如果变量不在使用，可以主动将其设置为null。这被称为解除引用。
2. 使用let和const。因为它们都是块作用域，所以相比于使用var，会更早地让垃圾回收程序介入，尽早回收应该回收的内存。
3. 避免全局变量的使用
4. 避免闭包的过度使用
5. 即时不使用的清理定时器
6. 隐藏类。比如两个变量是同一个类的实例。如果额外的对其中的一个增加属性或者删除属性，将会导致实例不再共享一个隐藏类。

## 浏览器的架构

## 浏览器的工作原理

## 浏览器有哪些进程？渲染进程中有哪些线程？

## from memory cache 与 from disk cache

## 渲染合成层
