## ğŸ˜Š è®¾è®¡: LRU

- [leetcodeåŸé¢˜åœ°å€](https://leetcode-cn.com/problems/lru-cache/)
### æ€è·¯

æœ¬é¢˜åˆ©ç”¨äº†`Map`æ•°æ®ç»“æ„çš„é¡ºåºæ€§ã€‚`keys()`è¿”å›çš„`key`çš„é¡ºåºï¼Œåæ’å…¥çš„æ’åœ¨åé¢ï¼Œå…ˆæ’å…¥çš„æ’åœ¨å‰é¢ã€‚ç¬¬ä¸€ä¸ª`key`å°±æ˜¯æœ€å¤è€çš„`key`ã€‚`put`å’Œ`get`æ—¶ï¼Œéœ€è¦æ›´æ–°`key`çš„é¡ºåºã€‚
### è§£ç­”

```js
/**
 * @param {number} capacity
 */
 var LRUCache = function(capacity) {
    this.capacity = capacity
    this.db = new Map()
};

/** 
 * @param {number} key
 * @return {number}
 */
LRUCache.prototype.get = function(key) {
    if (this.db.has(key)) {
        const value = this.db.get(key)
        // æ›´æ–°ä½ç½®
        this.db.delete(key)
        this.db.set(key, value)
        return value
    } else {
        return -1
    }
};

/** 
 * @param {number} key 
 * @param {number} value
 * @return {void}
 */
LRUCache.prototype.put = function(key, value) {
    const size = this.db.size
    if (this.db.has(key) || size < this.capacity) {
        if (this.db.has(key)) {
            this.db.get(key)
            // æ›´æ–°ä½ç½®
            this.db.delete(key)
        }
        this.db.set(key, value) 
    } else {
        const keys = [...this.db.keys()]
        // ä¸ç»å¸¸ä½¿ç”¨çš„key
        const lastKey = keys[0]
        this.db.delete(lastKey)
        this.db.set(key, value)
    }
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * var obj = new LRUCache(capacity)
 * var param_1 = obj.get(key)
 * obj.put(key,value)
 */
```

## ğŸ˜Š äºŒå‰æ ‘: äºŒå‰æ ‘çš„å››ç§éå†

- å‰åºéå†: å‰åºéå†é¦–å…ˆè®¿é—®æ ¹èŠ‚ç‚¹ï¼Œç„¶åéå†å·¦å­æ ‘ï¼Œæœ€åéå†å³å­æ ‘ã€‚
- ä¸­åºéå†: ä¸­åºéå†æ˜¯å…ˆéå†å·¦å­æ ‘ï¼Œç„¶åè®¿é—®æ ¹èŠ‚ç‚¹ï¼Œç„¶åéå†å³å­æ ‘ã€‚
- ååºéå†: ååºéå†æ˜¯å…ˆéå†å·¦å­æ ‘ï¼Œç„¶åéå†å³å­æ ‘ï¼Œæœ€åè®¿é—®æ ‘çš„æ ¹èŠ‚ç‚¹ã€‚
- å±‚åºéå†: å±‚åºéå†åˆæ˜¯å¹¿åº¦ä¼˜å…ˆéå†, ä»ä¸€ä¸ªæ ¹èŠ‚ç‚¹å¼€å§‹ï¼Œé¦–å…ˆè®¿é—®èŠ‚ç‚¹æœ¬èº«ã€‚ ç„¶åéå†å®ƒçš„ç›¸é‚»èŠ‚ç‚¹ï¼Œå…¶æ¬¡éå†å®ƒçš„äºŒçº§é‚»èŠ‚ç‚¹ã€ä¸‰çº§é‚»èŠ‚ç‚¹ï¼Œä»¥æ­¤ç±»æ¨ã€‚

### å‰åºéå†

- [leetcodeåŸé¢˜](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/submissions/)

```js
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
 var preorderTraversal = function(root) {
    const result = []

    const traverside = (node) => {
        if (node) {
            result.push(node.val)
            traverside(node.left)
            traverside(node.right)
        }
    };

    traverside(root)

    return result;
};
```

### ä¸­åºéå†

- [leetcodeåŸé¢˜](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

```js
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var inorderTraversal = function(root) {
    const result = []

    const traverside = (node) => {
        if (node) {
            traverside(node.left)
            result.push(node.val)
            traverside(node.right)
        }
    };

    traverside(root)

    return result;
};
```
### ååºéå†

- [leetcodeåŸé¢˜](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/submissions/)

```js
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var postorderTraversal = function(root) {
    const result = []

    const  = (node) => {
        if (node) {
            traverside(node.left)
            traverside(node.right)
            result.push(node.val)
        }
    };

    traverside(root)

    return result;
};
```

### å±‚åºéå†

- [leetcodeåŸé¢˜](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

```js
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
 var levelOrder = function(root) {
    const result = []

    const traverside = (nodes) => {
        if (nodes.length) {
            const childs = []
            const vals = []
            for (let i = 0; i < nodes.length; i += 1) {
                const node = nodes[i]
                vals.push(node.val)
                if (node.left) {
                    childs.push(node.left)
                }
                if (node.right) {
                    childs.push(node.right)
                }
            }
            result.push(vals)
            traverside(childs)
        }
    }

    if (root) {
        traverside([root])
    }

    return result
};
```


## ğŸ˜Š äºŒå‰æ ‘: ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘

- [leetcodeåŸé¢˜](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

### æ€è·¯

ç”±å‰åºéå†å¯ä»¥å¾—åˆ°æ ¹èŠ‚ç‚¹çš„å€¼(æ•°ç»„ä¸­çš„ç¬¬ä¸€ä¸ª), æˆ‘ä»¬ä½¿ç”¨æ ¹èŠ‚ç‚¹çš„å€¼åˆ†å‰²ä¸­åºéå†çš„æ•°ç»„ã€‚æˆ‘ä»¬å¯ä»¥å¾—åˆ°ä¸­åºéå†å·¦å­æ ‘å’Œä¸­åºéå†å³å­æ ‘ã€‚ä½¿ç”¨ä¸­åºéå†å·¦å­æ ‘å’Œä¸­åºéå†å³å­æ ‘çš„é•¿åº¦ï¼Œåˆ†å‰²å‰åºéå†çš„æ•°ç»„å¯ä»¥å¾—åˆ°å‰åºéå†å·¦å­æ ‘å’Œå‰åºéå†å³å­æ ‘ã€‚ç„¶åæ¥ç€é€’å½’åˆ†å‰²å³å¯ã€‚
### è§£ç­”

```js
/**
 * @param {number[]} preorder
 * @param {number[]} inorder
 * @return {TreeNode}
 */
 var buildTree = function(preorder, inorder) {

    const root = {
        val: null,
        left: null,
        right: null,
    }

    // æ„å»ºäºŒå‰æ ‘
    const construct = (preorder, inorder, node) => {
        if (preorder.length) {
            const left = {
                val: null,
                left: null,
                right: null,
            }

            const right = {
                val: null,
                left: null,
                right: null,
            }

            const root = preorder[0]
            const rootIndex = inorder.findIndex((val) => val === root)
            const inorderLeftTree = inorder.slice(0, rootIndex)
            const inorderRightTree = inorder.slice(rootIndex + 1)
            const inorderLeftTreeLen = inorderLeftTree.length
            const inorderRightTreeLen = inorderRightTree.length
            const preorderLeftTree = preorder.slice(1, inorderLeftTreeLen + 1)
            const preorderRightTree = preorder.slice(inorderLeftTreeLen + 1)
            
            node.val = preorder[0]
            node.left = inorderLeftTreeLen ? left : null
            node.right = inorderRightTreeLen ? right : null

            construct(preorderLeftTree, inorderLeftTree, left)
            construct(preorderRightTree, inorderRightTree, right)
        }
    }

    construct(preorder, inorder, root)

    return root;
};
```

## ğŸ˜Š äºŒå‰æ ‘: ä»ä¸­åºä¸ååºéå†åºåˆ—æ„é€ äºŒå‰æ ‘

- [leetcodeåŸé¢˜](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

### æ€è·¯

æ€è·¯å’Œä¸Šé¢˜ç±»ä¼¼, è¿™é‡Œä¸åœ¨èµ˜è¿°
### è§£ç­”

```js
/**
 * @param {number[]} inorder
 * @param {number[]} postorder
 * @return {TreeNode}
 */
var buildTree = function(inorder, postorder) {
    const root = {
        val: null,
        left: null,
        right: null,
    }

    const construct = (inorder, postorder, node) => {
        if (postorder.length) {
            const left = {
                val: null,
                left: null,
                right: null,
            }

            const right = {
                val: null,
                left: null,
                right: null,
            }

            const root = postorder[postorder.length - 1]
            const rootIndex = inorder.findIndex((val) => val === root)
            const inorderLeftTree = inorder.slice(0, rootIndex)
            const inorderRightTree = inorder.slice(rootIndex + 1)
            const inorderLeftTreeLen = inorderLeftTree.length
            const inorderRightTreeLen = inorderRightTree.length
            const postorderLeftTree = postorder.slice(0, inorderLeftTreeLen)
            const postorderRightTree = postorder.slice(inorderLeftTreeLen, postorder.length - 1)

            node.val = root
            node.left = inorderLeftTreeLen ? left : null
            node.right = inorderRightTreeLen ? right : null

            construct(inorderLeftTree, postorderLeftTree, left)
            construct(inorderRightTree, postorderRightTree, right)
        }
    }

    construct(inorder, postorder, root)

    return root;
};
```

## ğŸ˜Š äºŒå‰æ ‘: äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦  

- [leetcodeåŸé¢˜](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)
### æ€è·¯

æ·±åº¦ä¼˜å…ˆéå†äºŒå‰æ ‘ï¼ŒåŒæ—¶è®°å½•æœ€å¤§æ·±åº¦å³å¯ã€‚ï¼ˆå¹¿åº¦ä¼˜å…ˆåº”è¯¥ä¹Ÿå¯ä»¥ï¼‰
### è§£ç­”

```js
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {
    let max = 0

    const traverside = (node, depth) => {
        if (node) {
            max = Math.max(max, depth)
            traverside(node.left, depth + 1)
            traverside(node.right, depth + 1)
        }
    }

    traverside(root, 1)

    return max
};
```

## ğŸ˜Š äºŒå‰æ ‘: äºŒå‰æ ‘çš„æœ€å°æ·±åº¦   

- [leetcodeåŸé¢˜](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)
### æ€è·¯

ä½¿ç”¨å¹¿åº¦ä¼˜å…ˆéå†ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªæ²¡æœ‰å­èŠ‚ç‚¹çš„å­èŠ‚ç‚¹ï¼Œå½“å‰çš„å±‚çº§å°±æ˜¯æœ€å°æ·±åº¦
### è§£ç­”

```js
/**
 * @param {TreeNode} root
 * @return {number}
 */
var minDepth = function(root) {
    let min = Number.MAX_VALUE

    const traverside = (nodes, depth) => {
        if (nodes.length) {
            const childs = []
            for (let i = 0; i < nodes.length; i += 1) {
                const node = nodes[i]
                if (node.left) {
                    childs.push(node.left)
                }
                if (node.right) {
                    childs.push(node.right)
                }
                if (!node.left && !node.right) {
                    // æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹
                    min = Math.min(depth, min)
                    // ç»ˆæ­¢éå†
                    return
                }
            }
            traverside(childs, depth + 1)
        }
    }

    if (root) {
        traverside([root], 1)
    } else {
        return 0
    }

    return min
};
```

## ğŸ˜Š äºŒå‰æ ‘: äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ

## ğŸ˜Š äºŒå‰æ ‘: äºŒå‰æœç´¢æ ‘ä¸­çš„æœç´¢

## ğŸ˜Š äºŒå‰æ ‘: å¯¹ç§°äºŒå‰æ ‘

## ğŸ˜Š äºŒå‰æ ‘: äºŒå‰æ ‘çš„é”¯é½¿å½¢å±‚åºéå†

## ğŸ˜Š äºŒå‰æ ‘: äºŒå‰æ ‘çš„å³è§†å›¾

## ğŸ˜Š äºŒå‰æ ‘: å®Œå…¨äºŒå‰æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°

## ğŸ˜Š äºŒå‰æ ‘: äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ

## äºŒå‰æ ‘: éªŒè¯äºŒå‰æœç´¢æ ‘

## äºŒå‰æ ‘: åˆ é™¤äºŒå‰æœç´¢æ ‘ä¸­çš„èŠ‚ç‚¹

## æ•°ç»„: æ±‚æ•°ç»„é‡Œé¢æœ€å¤§è¿ç»­å­é¡¹çš„å’Œ

## åŠ¨æ€è§„åˆ’: æ±‚ä¸€ä¸ªæ•°ç»„æœ€å¤§å­é¡¹çš„å’Œï¼Œè¦æ±‚è¿™äº›å­é¡¹åœ¨æ•°ç»„ä¸­çš„ä½ç½®ä¸æ˜¯è¿ç»­çš„

## åŠ¨æ€è§„åˆ’: çˆ¬æ¥¼æ¢¯ & æ–æ³¢é‚£å¥‘æ•°

## ğŸ˜Š æ ˆ: æ‹¬å·æ˜¯å¦æœ‰æ•ˆ

## ğŸ˜Š æ ˆ: æœ€å°æ ˆ

## ğŸ˜Š æ ˆ: ç®€åŒ–è·¯å¾„

## ğŸ˜Š äºŒåˆ†æœç´¢: xçš„å¹³æ–¹æ ¹

## ğŸ˜Š äºŒåˆ†æœç´¢: åœ¨æ’åºæ•°ç»„ä¸­æŸ¥æ‰¾å…ƒç´ çš„ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªä½ç½®

## å †: æ•°ç»„ä¸­çš„ç¬¬Kä¸ªæœ€å¤§å…ƒç´ 

## ğŸ˜Š åŒæŒ‡é’ˆ: æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²

## ğŸ˜Š é“¾è¡¨: åè½¬é“¾è¡¨

## ğŸ˜Š é“¾è¡¨: ç¯å½¢é“¾è¡¨

## åŒæŒ‡é’ˆ: æœ€é•¿å…¬å…±å‰ç¼€

## ğŸ˜Š åŒæŒ‡é’ˆ: ç››æœ€å¤šæ°´çš„å®¹å™¨

## åŒæŒ‡é’ˆ: å¯»æ‰¾ä¸¤ä¸ªæ­£åºæ•°ç»„çš„ä¸­ä½æ•°

## ğŸ˜Š å‰ç¼€å’Œ: å’Œä¸ºKçš„å­æ•°ç»„

## å‰ç¼€æ ‘: å®ç°Trieæ ‘

## å‰ç¼€æ ‘: å•è¯æ›¿æ¢

## DFS: å²›å±¿çš„æœ€å¤§é¢ç§¯

## DFS: ç›¸åŒçš„æ ‘

## BFS: äºŒå‰æ ‘çš„æœ€å°æ·±åº¦

## ğŸ˜Š å›æº¯: Nçš‡å

## ğŸ˜Š å›æº¯: å…¨æ’åˆ—

## ğŸ˜Š å›æº¯: ç»„åˆ

## ğŸ˜Š å›æº¯: æ‹¬å·ç”Ÿæˆ

## ğŸ˜Š å›æº¯: å¤åŸIPåœ°å€

## ğŸ˜Š å›æº¯: å­é›†

## ğŸ˜Š å“ˆå¸Œ: ä¸¤æ•°ä¹‹å’Œ

## ğŸ˜Š å“ˆå¸Œ: ä¸‰æ•°ä¹‹å’Œ

## ğŸ˜Š å“ˆå¸Œ: å››æ•°ä¹‹å’Œ

## è´ªå¿ƒ: è·³è·ƒæ¸¸æˆ

## åŠ¨æ€è§„åˆ’: æœ€å¤§å­åºå’Œ

## åŠ¨æ€è§„åˆ’: é›¶é’±å…‘æ¢

## å­—ç¬¦ä¸²: å¤§æ•°ç›¸åŠ 


