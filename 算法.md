## 😊 设计: LRU

- [leetcode原题地址](https://leetcode-cn.com/problems/lru-cache/)
### 思路

本题利用了`Map`数据结构的顺序性。`keys()`返回的`key`的顺序，后插入的排在后面，先插入的排在前面。第一个`key`就是最古老的`key`。`put`和`get`时，需要更新`key`的顺序。
### 解答

```js
/**
 * @param {number} capacity
 */
 var LRUCache = function(capacity) {
    this.capacity = capacity
    this.db = new Map()
};

/** 
 * @param {number} key
 * @return {number}
 */
LRUCache.prototype.get = function(key) {
    if (this.db.has(key)) {
        const value = this.db.get(key)
        // 更新位置
        this.db.delete(key)
        this.db.set(key, value)
        return value
    } else {
        return -1
    }
};

/** 
 * @param {number} key 
 * @param {number} value
 * @return {void}
 */
LRUCache.prototype.put = function(key, value) {
    const size = this.db.size
    if (this.db.has(key) || size < this.capacity) {
        if (this.db.has(key)) {
            this.db.get(key)
            // 更新位置
            this.db.delete(key)
        }
        this.db.set(key, value) 
    } else {
        const keys = [...this.db.keys()]
        // 不经常使用的key
        const lastKey = keys[0]
        this.db.delete(lastKey)
        this.db.set(key, value)
    }
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * var obj = new LRUCache(capacity)
 * var param_1 = obj.get(key)
 * obj.put(key,value)
 */
```

## 二叉树: 二叉树的四种遍历

- 前序遍历: 前序遍历首先访问根节点，然后遍历左子树，最后遍历右子树。
- 中序遍历: 中序遍历是先遍历左子树，然后访问根节点，然后遍历右子树。
- 后序遍历: 后序遍历是先遍历左子树，然后遍历右子树，最后访问树的根节点。
- 层序遍历: 层序遍历又是广度优先遍历, 从一个根节点开始，首先访问节点本身。 然后遍历它的相邻节点，其次遍历它的二级邻节点、三级邻节点，以此类推。


### 前序遍历

- [leetcode原题](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/submissions/)

```js
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
 var preorderTraversal = function(root) {
    const result = []

    const traverside = (node) => {
        if (node) {
            result.push(node.val)
            traverside(node.left)
            traverside(node.right)
        }
    };

    traverside(root)

    return result;
};
```

### 中序遍历

- [leetcode原题](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

```js
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var inorderTraversal = function(root) {
    const result = []

    const traverside = (node) => {
        if (node) {
            traverside(node.left)
            result.push(node.val)
            traverside(node.right)
        }
    };

    traverside(root)

    return result;
};
```
### 后序遍历

```js
```

### 层序遍历

## 二叉树: 前序遍历, 中序遍历还原二叉树

## 二叉树: 后序遍历, 中序遍历还原二叉树

## 二叉树: 二叉树的深度

## 数组: 求数组里面最大连续子项的和

## 动态规划: 求一个数组最大子项的和，要求这些子项在数组中的位置不是连续的

## 动态规划: 爬楼梯 & 斐波那契数

## 栈: 括号是否有效

## 栈: 最小栈

## 二分搜索: x的平方根

## 堆: 数组中的第K个最大元素

## 双指针: 无重复字符的最长子串

## 链表: 反转链表

## 链表: 环形链表

## 双指针: 最长公共前缀

## 双指针: 盛最多水的容器

## 双指针: 寻找两个正序数组的中位数

## 前缀和: 和为K的子数组

## 二叉树: 二叉树的最近公共祖先

## 二叉树: 二叉搜索树中的搜索

## 二叉树: 删除二叉搜索树中的节点

## 二叉树: 对称二叉树

## 二叉搜索树: 验证二叉搜索树


## 前缀树: 实现Trie树

## 前缀树: 单词替换

## 二分搜索: 在排序数组中查找元素的第一个和最后一个位置
## DFS: 岛屿的最大面积

## DFS: 相同的树

## BFS: 二叉树的最小深度

## 回溯: N皇后

## 回溯: 全排列

## 回溯: 组合

## 回溯: 括号生成

## 哈希: 两数之和

## 哈希: 三数之和

## 哈希: 四数之和

## 贪心: 跳跃游戏

## 动态规划: 最大子序和

## 动态规划: 零钱兑换

## 字符串: 大数相加
