> æŒ‘é€‰äº†ç±³å“ˆæ¸¸ï¼Œç¾å›¢ï¼Œå’Œå¿«æ‰‹çš„é«˜é¢‘é¢˜ï¼ˆå¼€é€šçš„leetcodeä¼šå‘˜ğŸ˜Šï¼‰

## ğŸ˜Š è®¾è®¡: LRU

- [leetcodeåŸé¢˜åœ°å€](https://leetcode-cn.com/problems/lru-cache/)
### æ€è·¯

æœ¬é¢˜åˆ©ç”¨äº†`Map`æ•°æ®ç»“æ„çš„é¡ºåºæ€§ã€‚`keys()`è¿”å›çš„`key`çš„é¡ºåºï¼Œåæ’å…¥çš„æ’åœ¨åé¢ï¼Œå…ˆæ’å…¥çš„æ’åœ¨å‰é¢ã€‚ç¬¬ä¸€ä¸ª`key`å°±æ˜¯æœ€å¤è€çš„`key`ã€‚`put`å’Œ`get`æ—¶ï¼Œéœ€è¦æ›´æ–°`key`çš„é¡ºåºã€‚
### è§£ç­”

```js
/**
 * @param {number} capacity
 */
 var LRUCache = function(capacity) {
    this.capacity = capacity
    this.db = new Map()
};

/** 
 * @param {number} key
 * @return {number}
 */
LRUCache.prototype.get = function(key) {
    if (this.db.has(key)) {
        const value = this.db.get(key)
        // æ›´æ–°ä½ç½®
        this.db.delete(key)
        this.db.set(key, value)
        return value
    } else {
        return -1
    }
};

/** 
 * @param {number} key 
 * @param {number} value
 * @return {void}
 */
LRUCache.prototype.put = function(key, value) {
    const size = this.db.size
    if (this.db.has(key) || size < this.capacity) {
        if (this.db.has(key)) {
            this.db.get(key)
            // æ›´æ–°ä½ç½®
            this.db.delete(key)
        }
        this.db.set(key, value) 
    } else {
        const keys = [...this.db.keys()]
        // ä¸ç»å¸¸ä½¿ç”¨çš„key
        const lastKey = keys[0]
        this.db.delete(lastKey)
        this.db.set(key, value)
    }
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * var obj = new LRUCache(capacity)
 * var param_1 = obj.get(key)
 * obj.put(key,value)
 */
```

## ğŸ˜Š äºŒå‰æ ‘: äºŒå‰æ ‘çš„å››ç§éå†

- å‰åºéå†: å‰åºéå†é¦–å…ˆè®¿é—®æ ¹èŠ‚ç‚¹ï¼Œç„¶åéå†å·¦å­æ ‘ï¼Œæœ€åéå†å³å­æ ‘ã€‚
- ä¸­åºéå†: ä¸­åºéå†æ˜¯å…ˆéå†å·¦å­æ ‘ï¼Œç„¶åè®¿é—®æ ¹èŠ‚ç‚¹ï¼Œç„¶åéå†å³å­æ ‘ã€‚
- ååºéå†: ååºéå†æ˜¯å…ˆéå†å·¦å­æ ‘ï¼Œç„¶åéå†å³å­æ ‘ï¼Œæœ€åè®¿é—®æ ‘çš„æ ¹èŠ‚ç‚¹ã€‚
- å±‚åºéå†: å±‚åºéå†åˆæ˜¯å¹¿åº¦ä¼˜å…ˆéå†, ä»ä¸€ä¸ªæ ¹èŠ‚ç‚¹å¼€å§‹ï¼Œé¦–å…ˆè®¿é—®èŠ‚ç‚¹æœ¬èº«ã€‚ ç„¶åéå†å®ƒçš„ç›¸é‚»èŠ‚ç‚¹ï¼Œå…¶æ¬¡éå†å®ƒçš„äºŒçº§é‚»èŠ‚ç‚¹ã€ä¸‰çº§é‚»èŠ‚ç‚¹ï¼Œä»¥æ­¤ç±»æ¨ã€‚

### ğŸ˜Š å‰åºéå†

- [leetcodeåŸé¢˜](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/submissions/)

```js
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
 var preorderTraversal = function(root) {
    const result = []

    const traverside = (node) => {
        if (node) {
            result.push(node.val)
            traverside(node.left)
            traverside(node.right)
        }
    };

    traverside(root)

    return result;
};
```

### ğŸ˜Š ä¸­åºéå†

- [leetcodeåŸé¢˜](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

```js
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var inorderTraversal = function(root) {
    const result = []

    const traverside = (node) => {
        if (node) {
            traverside(node.left)
            result.push(node.val)
            traverside(node.right)
        }
    };

    traverside(root)

    return result;
};
```
### ğŸ˜Š ååºéå†

- [leetcodeåŸé¢˜](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/submissions/)

```js
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var postorderTraversal = function(root) {
    const result = []

    const  = (node) => {
        if (node) {
            traverside(node.left)
            traverside(node.right)
            result.push(node.val)
        }
    };

    traverside(root)

    return result;
};
```

### ğŸ˜Š å±‚åºéå†

- [leetcodeåŸé¢˜](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

```js
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
 var levelOrder = function(root) {
    const result = []

    const traverside = (nodes) => {
        if (nodes.length) {
            const childs = []
            const vals = []
            for (let i = 0; i < nodes.length; i += 1) {
                const node = nodes[i]
                vals.push(node.val)
                if (node.left) {
                    childs.push(node.left)
                }
                if (node.right) {
                    childs.push(node.right)
                }
            }
            result.push(vals)
            traverside(childs)
        }
    }

    if (root) {
        traverside([root])
    }

    return result
};
```
## ğŸ˜Š äºŒå‰æ ‘: ä»å‰åºä¸ä¸­åºéå†åºåˆ—æ„é€ äºŒå‰æ ‘

- [leetcodeåŸé¢˜](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

### æ€è·¯

ç”±å‰åºéå†å¯ä»¥å¾—åˆ°æ ¹èŠ‚ç‚¹çš„å€¼(æ•°ç»„ä¸­çš„ç¬¬ä¸€ä¸ª), æˆ‘ä»¬ä½¿ç”¨æ ¹èŠ‚ç‚¹çš„å€¼åˆ†å‰²ä¸­åºéå†çš„æ•°ç»„ã€‚æˆ‘ä»¬å¯ä»¥å¾—åˆ°ä¸­åºéå†å·¦å­æ ‘å’Œä¸­åºéå†å³å­æ ‘ã€‚ä½¿ç”¨ä¸­åºéå†å·¦å­æ ‘å’Œä¸­åºéå†å³å­æ ‘çš„é•¿åº¦ï¼Œåˆ†å‰²å‰åºéå†çš„æ•°ç»„å¯ä»¥å¾—åˆ°å‰åºéå†å·¦å­æ ‘å’Œå‰åºéå†å³å­æ ‘ã€‚ç„¶åæ¥ç€é€’å½’åˆ†å‰²å³å¯ã€‚
### è§£ç­”

```js
/**
 * @param {number[]} preorder
 * @param {number[]} inorder
 * @return {TreeNode}
 */
 var buildTree = function(preorder, inorder) {

    const root = {
        val: null,
        left: null,
        right: null,
    }

    // æ„å»ºäºŒå‰æ ‘
    const construct = (preorder, inorder, node) => {
        if (preorder.length) {
            const left = {
                val: null,
                left: null,
                right: null,
            }

            const right = {
                val: null,
                left: null,
                right: null,
            }

            const root = preorder[0]
            const rootIndex = inorder.findIndex((val) => val === root)
            const inorderLeftTree = inorder.slice(0, rootIndex)
            const inorderRightTree = inorder.slice(rootIndex + 1)
            const inorderLeftTreeLen = inorderLeftTree.length
            const inorderRightTreeLen = inorderRightTree.length
            const preorderLeftTree = preorder.slice(1, inorderLeftTreeLen + 1)
            const preorderRightTree = preorder.slice(inorderLeftTreeLen + 1)
            
            node.val = preorder[0]
            node.left = inorderLeftTreeLen ? left : null
            node.right = inorderRightTreeLen ? right : null

            construct(preorderLeftTree, inorderLeftTree, left)
            construct(preorderRightTree, inorderRightTree, right)
        }
    }

    construct(preorder, inorder, root)

    return root;
};
```

## ğŸ˜Š äºŒå‰æ ‘: ä»ä¸­åºä¸ååºéå†åºåˆ—æ„é€ äºŒå‰æ ‘

- [leetcodeåŸé¢˜](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

### æ€è·¯

æ€è·¯å’Œä¸Šé¢˜ç±»ä¼¼, è¿™é‡Œä¸åœ¨èµ˜è¿°
### è§£ç­”

```js
/**
 * @param {number[]} inorder
 * @param {number[]} postorder
 * @return {TreeNode}
 */
var buildTree = function(inorder, postorder) {
    const root = {
        val: null,
        left: null,
        right: null,
    }

    const construct = (inorder, postorder, node) => {
        if (postorder.length) {
            const left = {
                val: null,
                left: null,
                right: null,
            }

            const right = {
                val: null,
                left: null,
                right: null,
            }

            const root = postorder[postorder.length - 1]
            const rootIndex = inorder.findIndex((val) => val === root)
            const inorderLeftTree = inorder.slice(0, rootIndex)
            const inorderRightTree = inorder.slice(rootIndex + 1)
            const inorderLeftTreeLen = inorderLeftTree.length
            const inorderRightTreeLen = inorderRightTree.length
            const postorderLeftTree = postorder.slice(0, inorderLeftTreeLen)
            const postorderRightTree = postorder.slice(inorderLeftTreeLen, postorder.length - 1)

            node.val = root
            node.left = inorderLeftTreeLen ? left : null
            node.right = inorderRightTreeLen ? right : null

            construct(inorderLeftTree, postorderLeftTree, left)
            construct(inorderRightTree, postorderRightTree, right)
        }
    }

    construct(inorder, postorder, root)

    return root;
};
```

## ğŸ˜Š äºŒå‰æ ‘: äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦  

- [leetcodeåŸé¢˜](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)
### æ€è·¯

æ·±åº¦ä¼˜å…ˆéå†äºŒå‰æ ‘ï¼ŒåŒæ—¶è®°å½•æœ€å¤§æ·±åº¦å³å¯ã€‚ï¼ˆå¹¿åº¦ä¼˜å…ˆåº”è¯¥ä¹Ÿå¯ä»¥ï¼Œæ²¡æœ‰åšå°è¯•ï¼‰
### è§£ç­”

```js
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {
    let max = 0

    const traverside = (node, depth) => {
        if (node) {
            max = Math.max(max, depth)
            traverside(node.left, depth + 1)
            traverside(node.right, depth + 1)
        }
    }

    traverside(root, 1)

    return max
};
```

## ğŸ˜Š äºŒå‰æ ‘: äºŒå‰æ ‘çš„æœ€å°æ·±åº¦   

- [leetcodeåŸé¢˜](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)
### æ€è·¯

ä½¿ç”¨å¹¿åº¦ä¼˜å…ˆéå†ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªæ²¡æœ‰å­èŠ‚ç‚¹çš„å­èŠ‚ç‚¹ï¼Œå½“å‰çš„å±‚çº§å°±æ˜¯æœ€å°æ·±åº¦
### è§£ç­”

```js
/**
 * @param {TreeNode} root
 * @return {number}
 */
var minDepth = function(root) {
    let min = Number.MAX_VALUE

    const traverside = (nodes, depth) => {
        if (nodes.length) {
            const childs = []
            for (let i = 0; i < nodes.length; i += 1) {
                const node = nodes[i]
                if (node.left) {
                    childs.push(node.left)
                }
                if (node.right) {
                    childs.push(node.right)
                }
                if (!node.left && !node.right) {
                    // æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹
                    min = Math.min(depth, min)
                    // ç»ˆæ­¢éå†
                    return
                }
            }
            traverside(childs, depth + 1)
        }
    }

    if (root) {
        traverside([root], 1)
    } else {
        return 0
    }

    return min
};
```

## ğŸ˜Š äºŒå‰æ ‘: äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ

- [leetcodeåŸé¢˜](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

### æ€è·¯

éå†äºŒå‰æ ‘ï¼ŒåŒæ—¶ä½¿ç”¨`map`è®°å½•æ¯ä¸€ä¸ªèŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ã€‚ç„¶åä½¿ç”¨éå†`p`çš„æ‰€æœ‰çˆ¶èŠ‚ç‚¹ï¼Œå¹¶è®°å½•ã€‚ä¹‹åéå†`q`, æŸ¥æ‰¾`q`çš„çˆ¶èŠ‚ç‚¹æ˜¯å¦åœ¨`p`çš„çˆ¶èŠ‚ç‚¹è®°å½•ä¸­ã€‚
### è§£ç­”

```js
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */
 var lowestCommonAncestor = function(root, p, q) {
    if (p === q) return p
    if (p === root.val || q === root.val) return root.val

    const map = new Map()
    const parents = new Set()
    let result = null

    // éå†äºŒå‰æ ‘, è®°å½•æ¯ä¸€ä¸ªèŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹
    const traverside = (node) => {
        if (node) {
            if (node.left) {
                map.set(node.left, node)
            }
            if (node.right) {
                map.set(node.right, node)
            }
            traverside(node.left)
            traverside(node.right)
        }
    }
    map.set(root, null)
    traverside(root)

    while (p !== null) {
        parents.add(p)
        p = map.get(p)
    }

    while (q !== null) {
        if (parents.has(q)) {
            result = q
            break
        }
        q = map.get(q)
    }

    return result
};
```

## ğŸ˜Š äºŒå‰æ ‘: å¯¹ç§°äºŒå‰æ ‘

- [leetcodeåŸé¢˜](https://leetcode-cn.com/problems/symmetric-tree/)

### æ€è·¯

éå†äºŒå‰æ ‘ï¼Œä½†æ˜¯åŒæ—¶ä»ä¸¤ä¸ªæ–¹å‘éå†ï¼Œé•œåƒæ¯”è¾ƒ`val`å€¼æ˜¯å¦ç›¸ç­‰ã€‚
### è§£ç­”

```js
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
 var isSymmetric = function(root) {
    let result = true

    const traverside = (left, right) => {
        if (left && right) {
            const leftVal = left.val
            const rightVal = right.val
            if (leftVal === rightVal) {
                traverside(left.left, right.right)
                traverside(left.right, right.left)
            } else {
                result = false
            }
        } else {
            if (left || right) {
                result = false 
            }
        }
    }

    traverside(root, root)

    return result
};
```
## ğŸ˜Š äºŒå‰æ ‘: å¹³è¡¡äºŒå‰æ ‘

- [leetcodeåŸé¢˜](https://leetcode-cn.com/problems/balanced-binary-tree/)

### æ€è·¯

### è§£ç­”

```js
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
 var isBalanced = function(root) {
    if (!root) return true

    let result = true

    // è·å–èŠ‚ç‚¹é«˜çš„
    const getDepth = (node) => {
        if (node) {
            return Math.max(getDepth(node.left), getDepth(node.right)) + 1
        } else {
            return 0
        }
    }

    const traverside = (node) => {
        if (node) {
            const leftNode = node.left
            const rightNode = node.right
            const leftDepth = getDepth(leftNode, 0)
            const rightDepth = getDepth(rightNode, 0)
            if (Math.abs(rightDepth - leftDepth) <= 1) {
                // å·¦å³å­èŠ‚ç‚¹ç»§ç»­å‘ä¸‹æŸ¥æ‰¾
                traverside(leftNode)
                traverside(rightNode)
            } else {
                result = false
                return
            }
        }
    }

    traverside(root)

    return result
};
```

## ğŸ˜Š äºŒå‰æ ‘: ç¿»è½¬äºŒå‰æ ‘

- [leetcodeåŸé¢˜](https://leetcode-cn.com/problems/invert-binary-tree/)

### æ€è·¯

### è§£ç­”

```js
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
 var invertTree = function(root) {
    const traverside = (node) => {
        if (node) {
            const left = node.left
            const right = node.right
            traverside(left)
            traverside(right)
            node.left = right
            node.right = left
        }
    }

    traverside(root, root)

    return root
};
```

## ğŸ˜Š äºŒå‰æ ‘: äºŒå‰æ ‘çš„å³è§†å›¾

- [leetcodeåŸé¢˜](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

### æ€è·¯

å±‚åºéå†å³å¯, ç„¶åè·å–æ¯ä¸€å±‚éå†çš„æœ€åä¸€ä¸ªå€¼
### è§£ç­”

```js
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var rightSideView = function(root) {
    if (!root) return []

    const result = []

    const traverside = (nodes) => {
        const len = nodes.length
        if (len) {
            const childs = []
            for (let i = 0; i < len; i += 1) {
                const node = nodes[i]
                if (i === len - 1) {
                    result.push(node.val)
                }
                if (node.left) {
                    childs.push(node.left)
                }
                if (node.right) {
                    childs.push(node.right)
                }
            }
            traverside(childs)
        }
    }

    traverside([root])

    return result
};
```

## ğŸ˜Š äºŒå‰æ ‘: äºŒå‰æ ‘çš„é”¯é½¿å½¢å±‚åºéå†

- [leetcodeåŸé¢˜](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)

### æ€è·¯

å±‚åºéå†åˆ¤æ–­æ¯ä¸€å±‚çš„å¥‡å¶å³å¯
### è§£ç­”

```js
var zigzagLevelOrder = function(root) {
    if (!root) return []

    const result = []

    const traverside = (nodes, level) => {
        const len = nodes.length
        if (len) {
            const childs = []
            const vals = []
            for (let i = 0; i < len; i += 1) {
                const node = nodes[i]
                vals.push(node.val)
                if (node.left) {
                    childs.push(node.left)
                }
                if (node.right) {
                    childs.push(node.right)
                }
            }
            if ((level & 1) === 0) {
                // å¶æ•°
                vals.reverse()
            }
            result.push(vals)
            traverside(childs, level + 1)
        }
    }

    traverside([root], 1)

    return result
};
```
## ğŸ˜Š äºŒå‰æ ‘: è·¯å¾„æ€»å’Œ

- [leetcodeåŸé¢˜](https://leetcode-cn.com/problems/path-sum/)

### æ€è·¯

### è§£ç­”

```js
/**
 * @param {TreeNode} root
 * @param {number} targetSum
 * @return {boolean}
 */
var hasPathSum = function(root, targetSum) {
    if (!root) return false

    let result = false

    const traverside = (node, sum) => {
        if (node) {
            sum += node.val
            if (!node.left && !node.right) {
                // è¯´æ˜æ˜¯å¶å­èŠ‚ç‚¹
                if (sum === targetSum) {
                    result = true
                    return
                }
            } else {
                traverside(node.left, sum)
                traverside(node.right, sum)
            }
        }
    }

    traverside(root, 0)

    return result
};
```

## ğŸ˜Š äºŒå‰æ ‘: è·¯å¾„æ€»å’Œ II

- [leetcodeåŸé¢˜](https://leetcode-cn.com/problems/path-sum-ii/)

### æ€è·¯


### è§£ç­”

```js
/**
 * @param {TreeNode} root
 * @param {number} targetSum
 * @return {number[][]}
 */
var pathSum = function(root, targetSum) {
    if (!root) return []

    const result = []

    const traverside = (node, arr, sum) => {
        if (node) {
            sum += node.val
            arr.push(node.val)
            if (!node.left && !node.right) {
                // è¯´æ˜æ˜¯å¶å­èŠ‚ç‚¹
                if (sum === targetSum) {
                    result.push(arr)
                }
            } else {
                traverside(node.left, [...arr], sum)
                traverside(node.right, [...arr], sum)
            }
        }
    }

    traverside(root, [], 0)

    return result
};
```
## ğŸ˜Š äºŒå‰æ ‘: äºŒå‰æ ‘å±•å¼€ä¸ºé“¾è¡¨

- [leetcodeåŸé¢˜](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)

### æ€è·¯

### è§£ç­”

```js
/**
 * @param {TreeNode} root
 * @return {void} Do not return anything, modify root in-place instead.
 */
var flatten = function(root) {
    if (!root) return root
    if (!root.left && !root.right) return root

    const getRight = (node) => {
        if (node.right) {
            return getRight(node.right)
        } else {
            return node
        }
    }

    const traverside = (node) => {
        if (node) {
            const left = node.left
            const right = node.right
            if (left) {
                const rNode = getRight(left)
                rNode.right = right
                node.right = left
            }
            node.left = null
            traverside(node.right)
        }
    }

    traverside(root)

    return root
};
```

## ğŸ˜Š äºŒå‰æ ‘: å®Œå…¨äºŒå‰æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°

- [leetcodeåŸé¢˜](https://leetcode-cn.com/problems/count-complete-tree-nodes/)

### æ€è·¯

### è§£ç­”

```js
```

## ğŸ˜Š äºŒå‰æ ‘: éªŒè¯äºŒå‰æœç´¢æ ‘

- [leetcodeåŸé¢˜](https://leetcode-cn.com/problems/validate-binary-search-tree/)

### æ€è·¯

ä½¿ç”¨ä¸­åºéå†ã€‚ä¸­åºéå†æ˜¯å…ˆéå†å·¦å­æ ‘ï¼Œç„¶åè®¿é—®æ ¹èŠ‚ç‚¹ï¼Œç„¶åéå†å³å­æ ‘ã€‚å¦‚æœæ˜¯äºŒå‰æœç´¢æ ‘ï¼Œç»“æœæ˜¯ä¸€ä¸ªé€’å¢çš„æ•°ç»„

### è§£ç­”

```js
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isValidBST = function(root) {
    if (!root) return false

    const vals = []

    const traverside = (node) => {
        if (node) {
            traverside(node.left)
            vals.push(node.val)
            traverside(node.right)
        }
    }

    traverside(root)

    const before = vals.join(',')
    const after = [...new Set(vals.sort((a, b) => a - b))].join(',')
    
    return before === after
};
```

## ğŸ˜Š äºŒå‰æ ‘: åˆ é™¤äºŒå‰æœç´¢æ ‘ä¸­çš„èŠ‚ç‚¹

## ğŸ˜Š äºŒå‰æ ‘: äºŒå‰æœç´¢æ ‘ä¸­çš„æœç´¢

## ğŸ˜Š å“ˆå¸Œ: å¿«ä¹æ•°

- [leetcodeåŸé¢˜](https://leetcode-cn.com/problems/happy-number/)

### æ€è·¯

ä½¿ç”¨hashæ£€æŸ¥æ•°å­—æ˜¯å¦é‡å¤å‡ºç°ï¼Œå¦‚æœé‡å¤å‡ºç°åˆ™æ°¸è¿œä¸èƒ½åˆ°è¾¾1ã€‚
### è§£ç­”

```js
/**
 * @param {number} n
 * @return {boolean}
 */
var isHappy = function(n) {
    const hash = {}

    const happy = (num) => {
        if (!hash[num]) {
            hash[num] = true
        } else {
            return false
        }
        const str = String(num)
        let s = 0
        for (let i = 0; i < str.length; i += 1) {
            s += Number(str[i]) ** 2
        }
        if (s === 1) {
            return true
        }
        return happy(s)
    }

    return happy(n)
};
```

## ğŸ˜Š å“ˆå¸Œ: ä¸‰æ•°ä¹‹å’Œ

- [leetcodeåŸé¢˜](https://leetcode-cn.com/problems/3sum/)

### æ€è·¯

### è§£ç­”

```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var threeSum = function(nums) {

};
```

## ğŸ˜Š å“ˆå¸Œ: å››æ•°ä¹‹å’Œ

- [leetcodeåŸé¢˜](https://leetcode-cn.com/problemset/all/?search=%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C)
### æ€è·¯

### è§£ç­”

```js

```

## ğŸ˜Š æ ˆ: æ‹¬å·æ˜¯å¦æœ‰æ•ˆ

## ğŸ˜Š æ ˆ: æœ€å°æ ˆ

## ğŸ˜Š æ ˆ: ç”¨æ ˆå®ç°é˜Ÿåˆ—

## ğŸ˜Š æ ˆ: ç§»é™¤æ— æ•ˆçš„æ‹¬å·

- [leetcodeåŸé¢˜](https://leetcode-cn.com/problems/minimum-remove-to-make-valid-parentheses/)

### æ€è·¯

ä½¿ç”¨æ ˆæ•°æ®ç»“æ„

### è§£ç­”

```js
var minRemoveToMakeValid = function(s) {
    let stackTop = ''
    // éæ³•æ‹¬å·çš„ç´¢å¼•
    let errIndexs = []
    const stack = []

    for (let i = 0; i < s.length; i += 1) {
        if (s[i] === '(' || s[i] === ')') {
            if (!stack.length) {
                if (s[i] === '(') {
                    stack.push(i)
                } else {
                    // éæ³•çš„æ‹¬å·
                    errIndexs.push(i)
                }
            } else {
                const top = s[stack[stack.length - 1]]
                if (
                    (top === '(' && s[i] === ')')
                ) {
                    stack.pop()
                } else {
                    stack.push(i)
                }
            } 
        }
    } 

    // å¦‚æœæ²¡æœ‰ç©ºï¼Œè¯´æ˜ä¹Ÿæ˜¯éæ³•çš„
    if (stack.length) {
        errIndexs = [...errIndexs, ...stack]
    }

    return [...s].filter((_, index) => !errIndexs.includes(index)).join('')
};
```

## ğŸ˜Š æ ˆ: ç®€åŒ–è·¯å¾„

## ğŸ˜Š äºŒåˆ†æœç´¢: xçš„å¹³æ–¹æ ¹

## ğŸ˜Š äºŒåˆ†æœç´¢: åœ¨æ’åºæ•°ç»„ä¸­æŸ¥æ‰¾å…ƒç´ çš„ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªä½ç½®

## ğŸ˜Š é“¾è¡¨: åè½¬é“¾è¡¨

## ğŸ˜Š é“¾è¡¨: ç¯å½¢é“¾è¡¨

## ğŸ˜Š é“¾è¡¨: æ’åºé“¾è¡¨

## ğŸ˜Š é“¾è¡¨: å›æ–‡é“¾è¡¨

## ğŸ˜Š é“¾è¡¨: åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨

## ğŸ˜Š é“¾è¡¨: æ’åºé“¾è¡¨

## ğŸ˜Š é“¾è¡¨: ç›¸äº¤é“¾è¡¨

## ğŸ˜Š åŠ¨æ€è§„åˆ’: æœ€å¤§å­åºå’Œ

- [leetcodeåŸé¢˜](https://leetcode-cn.com/problems/maximum-subarray/)

### æ€è·¯

æ±‚è¿ç»­æœ€é•¿å­åºåˆ—çš„å’Œã€‚å¦‚æœä¹‹å‰çš„è¿ç»­å­åºåˆ—å’Œæ˜¯è´Ÿæ•°ï¼Œæˆ‘ä»¬åœ¨è®¡ç®—å½“å‰ä½ç½®çš„å­åºåˆ—å’Œæ—¶ä¸èƒ½åŒ…å«ä¹‹å‰çš„å’Œã€‚æ­¤æ—¶å½“å‰çš„å’Œï¼Œå°±æ˜¯å½“å‰çš„æ•°å­—ã€‚å¦‚æœä¹‹å‰çš„è¿ç»­å­åºåˆ—å’Œæ˜¯å¤§äºç­‰äº0çš„ï¼Œæˆ‘ä»¬åœ¨è®¡ç®—å½“å‰ä½ç½®çš„å­åºåˆ—å’Œæ—¶åˆ™éœ€è¦åŒ…å«ä¹‹å‰çš„å’Œã€‚
### è§£ç­”

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function(nums) {
    const dp = [nums[0]]

    for (let i = 1; i < nums.length; i += 1) {
        if (dp[i - 1] >= 0) {
            dp[i] = dp[i - 1] + nums[i]
        } else {
            dp[i] = nums[i]
        }
    }

    return Math.max(...dp)
};
```

## ğŸ˜Š åŠ¨æ€è§„åˆ’: é›¶é’±å…‘æ¢

## ğŸ˜Š åŠ¨æ€è§„åˆ’: ä¸åŒè·¯å¾„

## ğŸ˜Š åŠ¨æ€è§„åˆ’: ä¸åŒè·¯å¾„ II

## ğŸ˜Š åŠ¨æ€è§„åˆ’: çˆ¬æ¥¼æ¢¯

- [leetcodeåŸé¢˜](https://leetcode-cn.com/problems/min-cost-climbing-stairs/)

### æ€è·¯

çˆ¬ä¸€å±‚æ¥¼æ¢¯ï¼Œ1ç§ç»„åˆã€‚çˆ¬äºŒå±‚æ¥¼æ¢¯ï¼Œ2ç§ç»„åˆã€‚çˆ¬ä¸‰å±‚æ¥¼æ¢¯ï¼Œ3ç§ç»„åˆã€‚çˆ¬å››å±‚æ¥¼æ¢¯ï¼Œ5ç§ç»„åˆã€‚çˆ¬nå±‚æ¥¼æ¢¯, (n - 1)å±‚ç»„åˆåŠ (n - 2)å±‚ç»„åˆã€‚

`dp(x)`è¡¨ç¤ºçˆ¬åˆ°ç¬¬xçº§å°é˜¶çš„æ–¹æ¡ˆæ•°ï¼Œè€ƒè™‘æœ€åä¸€æ­¥å¯èƒ½è·¨äº†ä¸€çº§å°é˜¶ï¼Œä¹Ÿå¯èƒ½è·¨äº†ä¸¤çº§å°é˜¶ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥åˆ—å‡ºå¦‚ä¸‹å¼å­ï¼š`dp(x) = dp(x - 1) + dp(x - 2)`

- n = 1, [1] => 1
- n = 2, [1,1] [2] => 2
- n = 3, [1,1,1] [1,2] [2,1] => 3
- n = 4, [1,1,1,1] [1,1,2] [1,2,1] [1,1,2] [2,2] => 5
- n = 5, [1,1,1,1,1] [2,1,1,1] [1,2,1,1] [1,1,2,1] [1,1,1,2] [2,2,1] [2,1,2] [1,2,2] => 8
### è§£ç­”

```js
/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function(n) {
    if (n < 3) return n

    const dp = [1, 2]
    
    for (let i = 2; i < n; i += 1) {
        dp[i] = dp[i - 1] + dp[i - 2]
    }
    return dp[dp.length - 1]
};
```

## ğŸ˜Š åŠ¨æ€è§„åˆ’: ä½¿ç”¨æœ€å°èŠ±è´¹çˆ¬æ¥¼æ¢¯

- [leetcodeåŸé¢˜](https://leetcode-cn.com/problems/min-cost-climbing-stairs/)

### ğŸ‘€ æ€è·¯

### è§£ç­”

```js
/**
 * @param {number[]} cost
 * @return {number}
 */
var minCostClimbingStairs = function(cost) {
    // æœ€åä¸€æ­¥ç›¸å½“äºæ²¡æœ‰æ¶ˆè€—èƒ½é‡çš„ä¸€æ­¥
    cost.push(0)
    const dp1 = [] // ä»0å¼€å§‹
    const dp2 = [] // ä»1å¼€å§‹
    const init1 = cost[0] // ä»0å¼€å§‹çš„åˆå§‹å€¼
    const init2 = cost[1] // ä»1å¼€å§‹çš„åˆå§‹å€¼
    const cost1 = cost.slice(1)
    const cost2 = cost.slice(2)


    // ä»0å¼€å§‹çš„
    for (let i = 0; i < cost1.length; i += 1) {
        if (i <= 1) {
            dp1[i] = cost1[i]
        } else {
            const a = cost1[i] + dp1[i - 1]
            const b = cost1[i] + dp1[i - 2]
            dp1[i] = Math.min(a, b)
        }
    }

    // ä»1å¼€å§‹çš„
    for (let i = 0; i < cost2.length; i += 1) {
        if (i <= 1) {
            dp2[i] = cost2[i]
        } else {
            const a = cost2[i] + dp2[i - 1]
            const b = cost2[i] + dp2[i - 2]
            dp2[i] = Math.min(a, b)
        }
    }

    return Math.min(dp1[dp1.length - 1] + init1, dp2[dp2.length - 1] + init2)
};
```
## ğŸ˜Š åŠ¨æ€è§„åˆ’: æœ€å¤§æ­£æ–¹å½¢

- [leetcodeåŸé¢˜](https://leetcode-cn.com/problems/maximal-square/)

### æ€è·¯

### è§£ç­”

```js
/**
 * @param {character[][]} matrix
 * @return {number}
 */
var maximalSquare = function(matrix) {
    if (!matrix.length) {
        return 0
    }

    const dp = []
    const w = matrix[0].length
    const h = matrix.length
    let max = 0


    for (let i = 0; i < h; i += 1) {
        dp.push([])
    }

    for (let i = 0; i < h; i += 1) {
        for (let j = 0; j < w; j += 1) {
            if (i === 0 || j === 0) {
                dp[i][j] = Number(matrix[i][j])
            } else {
                const t = Number(dp[i - 1][j])
                const l = Number(dp[i][j - 1])
                const lt = Number(dp[i - 1][j - 1])
                const cur = Number(matrix[i][j])
                if (cur === 0) {
                    dp[i][j] = 0
                } else {
                    dp[i][j] = Math.min(t, l, lt) + 1
                }
            }
            max = Math.max(dp[i][j], max)
        }
    }

    return max ** 2
};
```
## ğŸ˜Š åŠ¨æ€è§„åˆ’: æ‰“å®¶åŠ«èˆ

- [leetcodeåŸé¢˜](https://leetcode-cn.com/problems/house-robber/)

### æ€è·¯

å°å·é‡åˆ°æ¯ä¸€å®¶æœ‰ä¸¤ä¸ªé€‰æ‹©å·æˆ–è€…ä¸å·ã€‚
    - å¦‚æœé€‰æ‹©å·ï¼Œé‚£ä¹ˆç›—çªƒçš„æ€»é‡‘é¢ç­‰äºå‰ä¸€å®¶ä¸å·çš„é‡‘é¢åŠ ä¸Šå½“å‰è¿™å®¶çš„é‡‘é¢ã€‚
    - å¦‚æœé€‰æ‹©ä¸å·ï¼Œé‚£ä¹ˆç›—çªƒçš„æ€»é‡‘é¢ç­‰äºä¹‹å‰ä¸å·å’Œå·ä¸­çš„æœ€å¤§å€¼ã€‚
### è§£ç­”

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function(nums) {
    // å·
    const dp1 = [nums[0]]
    // ä¸å·
    const dp2 = [0]

    for (let i = 1; i < nums.length; i += 1) {
        dp1[i] = dp2[i - 1] + nums[i]
        dp2[i] = Math.max(dp1[i - 1], dp2[i - 1])
    }

    return Math.max(dp1[dp1.length - 1], dp2[dp2.length - 1]);
};
```

## ğŸ˜Š åŠ¨æ€è§„åˆ’: æ‰“å®¶åŠ«èˆ II

- [leetcodeåŸé¢˜](https://leetcode-cn.com/problems/house-robber-ii/)

### ğŸ‘€ æ€è·¯

### è§£ç­”

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var rob = function(nums) {
    // é€‰æ‹©å·ç¬¬ä¸€å®¶ï¼Œç„¶åæ¯ä¸€æˆ·é€‰æ‹©å·
    const dp1 = [nums[0], nums[0]]
    // é€‰æ‹©å·ç¬¬ä¸€å®¶ï¼Œç„¶åæ¯ä¸€æˆ·é€‰æ‹©ä¸å·
    const dp2 = [nums[0], nums[0]]
    // é€‰æ‹©ä¸å·ç¬¬ä¸€å®¶ï¼Œç„¶åæ¯ä¸€æˆ·é€‰æ‹©å·
    const dp3 = [0]
    // é€‰æ‹©ä¸å·ç¬¬ä¸€å®¶ï¼Œç„¶åæ¯ä¸€æˆ·é€‰æ‹©ä¸å·
    const dp4 = [0]

    for (let i = 2; i < nums.length - 1; i += 1) {
        dp1[i] = dp2[i - 1] + nums[i]
        dp2[i] = Math.max(dp1[i - 1], dp2[i - 1])
    }

    for (let i = 1; i < nums.length; i += 1) {
        dp3[i] = dp4[i - 1] + nums[i]
        dp4[i] = Math.max(dp3[i - 1], dp4[i - 1])
    }

    return Math.max(
        dp1[dp1.length - 1],
        dp2[dp2.length - 1],
        dp3[dp3.length - 1],
        dp4[dp4.length - 1],
    );
};
```

## ğŸ˜Š åŠ¨æ€è§„åˆ’: ç²‰åˆ·æˆ¿å­

- [leetcodeåŸé¢˜](https://leetcode-cn.com/problems/paint-house/)

### æ€è·¯

### è§£ç­”

```js
/**
 * @param {number[][]} costs
 * @return {number}
 */
var minCost = function(costs) {

};
```

## ğŸ˜Š åŠ¨æ€è§„åˆ’: ç²‰åˆ·æˆ¿å­ II

## ğŸ˜Š åŠ¨æ€è§„åˆ’ï¼šæœ€å°è·¯å¾„å’Œ

## ğŸ˜Š åŠ¨æ€è§„åˆ’: æœ€é•¿é€’å¢å­åºåˆ—

- [leetcodeåŸé¢˜](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

### ğŸ‘€ æ€è·¯

### è§£ç­”

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var lengthOfLIS = function(nums) {
    const dp = [1]

    for (let i = 1; i < nums.length; i += 1) {
        dp[i] = 1
        const a = nums[i]
        for (let j = 0; j < i; j += 1) {
            const b = nums[j]
            if (a > b) {
                dp[i] = Math.max(dp[i], dp[j] + 1)
            }
        }
    }

    return Math.max(...dp)
};
```

## ğŸ˜Š åŠ¨æ€è§„åˆ’: æœ€é•¿å…¬å…±å­åºåˆ—

- [leetcodeåŸé¢˜](https://leetcode-cn.com/problems/longest-common-subsequence/)

### æ€è·¯

äºŒç»´åŠ¨æ€è§„åˆ’
### è§£ç­”

```js
/**
 * @param {string} text1
 * @param {string} text2
 * @return {number}
 */
var longestCommonSubsequence = function(text1, text2) {
};
```
## ğŸ˜Š å †: æ•°ç»„ä¸­çš„ç¬¬Kä¸ªæœ€å¤§å…ƒç´ 

- [leetcodeåŸé¢˜](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)
### æ€è·¯

å †æ’åºï¼Œåˆ†æ²»

### è§£ç­”

```js
// å †æ’åº
```

```js
// åˆ†æ²»
```

## ğŸ˜Š å †: æœ€å°çš„kä¸ªæ•°

## ğŸ˜Š åŒæŒ‡é’ˆ: æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²

## ğŸ˜Š åŒæŒ‡é’ˆ: ç››æœ€å¤šæ°´çš„å®¹å™¨

## ğŸ˜Š åŒæŒ‡é’ˆ: æœ€é•¿å…¬å…±å‰ç¼€

## ğŸ˜Š åŒæŒ‡é’ˆ: å¯»æ‰¾ä¸¤ä¸ªæ­£åºæ•°ç»„çš„ä¸­ä½æ•°

## ğŸ˜Š å‰ç¼€å’Œ: å’Œä¸ºKçš„å­æ•°ç»„

## ğŸ˜Š å‰ç¼€æ ‘: å®ç°Trieæ ‘

## ğŸ˜Š å‰ç¼€æ ‘: å•è¯æ›¿æ¢

## ğŸ˜Š DFS: å²›å±¿çš„æœ€å¤§é¢ç§¯

## ğŸ˜Š DFS: ç›¸åŒçš„æ ‘

## ğŸ˜Š BFS: äºŒå‰æ ‘çš„æœ€å°æ·±åº¦

## ğŸ˜Š åˆ†æ²»: å¤šæ•°å…ƒç´ 

## ğŸ˜Š å›æº¯: Nçš‡å

## ğŸ˜Š å›æº¯: å…¨æ’åˆ—

## ğŸ˜Š å›æº¯: ç»„åˆ

## ğŸ˜Š å›æº¯: æ‹¬å·ç”Ÿæˆ

## ğŸ˜Š å›æº¯: å¤åŸIPåœ°å€

## ğŸ˜Š å›æº¯: å­é›†

## ğŸ˜Š è´ªå¿ƒ: è·³è·ƒæ¸¸æˆ

## ğŸ˜Š å­—ç¬¦ä¸²: å¤§æ•°ç›¸åŠ 

## ğŸ˜Š å­—ç¬¦ä¸²: æ¯”è¾ƒç‰ˆæœ¬å·

## ğŸ˜Š æ•°ç»„: æ±‚æ•°ç»„é‡Œé¢æœ€å¤§è¿ç»­å­é¡¹çš„å’Œ

## ğŸ˜Š æ•°ç»„: ä¸ç›¸äº¤çš„çº¿

## ğŸ˜Š æ•°ç»„: æ‰¾åˆ°æ‰€æœ‰æ•°ç»„ä¸­æ¶ˆå¤±çš„æ•°å­—

## ğŸ˜Š æ•°ç»„: ç¯å½¢å­æ•°ç»„çš„æœ€å¤§å’Œ


## ğŸ˜Š æ•°ç»„: èºæ—‹çŸ©é˜µ

## ğŸ˜Š æ•°ç»„: èºæ—‹çŸ©é˜µ II

## ğŸ˜Š å­—ç¬¦ä¸²: æœ‰æ•ˆçš„æ‹¬å·å­—ç¬¦ä¸²

## ğŸ˜Š æ•°å­¦: åˆ†æ•°åŠ å‡è¿ç®—

## ğŸ˜Š æ•°å­¦: æ•´æ•°åè½¬

## ğŸ˜Š æ•°å­¦: å­—ç¬¦ä¸²è½¬æ¢æ•´æ•° (atoi)

## ğŸ˜Š ç”²æ¿ä¸Šçš„æˆ˜èˆ°
