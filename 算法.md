> 挑选了米哈游，美团，和快手的高频题（开通的leetcode会员😊）

## 😊 设计: LRU

- [leetcode原题地址](https://leetcode-cn.com/problems/lru-cache/)
### 思路

本题利用了`Map`数据结构的顺序性。`keys()`返回的`key`的顺序，后插入的排在后面，先插入的排在前面。第一个`key`就是最古老的`key`。`put`和`get`时，需要更新`key`的顺序。
### 解答

```js
/**
 * @param {number} capacity
 */
 var LRUCache = function(capacity) {
    this.capacity = capacity
    this.db = new Map()
};

/** 
 * @param {number} key
 * @return {number}
 */
LRUCache.prototype.get = function(key) {
    if (this.db.has(key)) {
        const value = this.db.get(key)
        // 更新位置
        this.db.delete(key)
        this.db.set(key, value)
        return value
    } else {
        return -1
    }
};

/** 
 * @param {number} key 
 * @param {number} value
 * @return {void}
 */
LRUCache.prototype.put = function(key, value) {
    const size = this.db.size
    if (this.db.has(key) || size < this.capacity) {
        if (this.db.has(key)) {
            this.db.get(key)
            // 更新位置
            this.db.delete(key)
        }
        this.db.set(key, value) 
    } else {
        const keys = [...this.db.keys()]
        // 不经常使用的key
        const lastKey = keys[0]
        this.db.delete(lastKey)
        this.db.set(key, value)
    }
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * var obj = new LRUCache(capacity)
 * var param_1 = obj.get(key)
 * obj.put(key,value)
 */
```

## 😊 二叉树: 二叉树的四种遍历

- 前序遍历: 前序遍历首先访问根节点，然后遍历左子树，最后遍历右子树。
- 中序遍历: 中序遍历是先遍历左子树，然后访问根节点，然后遍历右子树。
- 后序遍历: 后序遍历是先遍历左子树，然后遍历右子树，最后访问树的根节点。
- 层序遍历: 层序遍历又是广度优先遍历, 从一个根节点开始，首先访问节点本身。 然后遍历它的相邻节点，其次遍历它的二级邻节点、三级邻节点，以此类推。

### 😊 前序遍历

- [leetcode原题](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/submissions/)

```js
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
 var preorderTraversal = function(root) {
    const result = []

    const traverside = (node) => {
        if (node) {
            result.push(node.val)
            traverside(node.left)
            traverside(node.right)
        }
    };

    traverside(root)

    return result;
};
```

### 😊 中序遍历

- [leetcode原题](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

```js
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var inorderTraversal = function(root) {
    const result = []

    const traverside = (node) => {
        if (node) {
            traverside(node.left)
            result.push(node.val)
            traverside(node.right)
        }
    };

    traverside(root)

    return result;
};
```
### 😊 后序遍历

- [leetcode原题](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/submissions/)

```js
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var postorderTraversal = function(root) {
    const result = []

    const  = (node) => {
        if (node) {
            traverside(node.left)
            traverside(node.right)
            result.push(node.val)
        }
    };

    traverside(root)

    return result;
};
```

### 😊 层序遍历

- [leetcode原题](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

```js
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
 var levelOrder = function(root) {
    const result = []

    const traverside = (nodes) => {
        if (nodes.length) {
            const childs = []
            const vals = []
            for (let i = 0; i < nodes.length; i += 1) {
                const node = nodes[i]
                vals.push(node.val)
                if (node.left) {
                    childs.push(node.left)
                }
                if (node.right) {
                    childs.push(node.right)
                }
            }
            result.push(vals)
            traverside(childs)
        }
    }

    if (root) {
        traverside([root])
    }

    return result
};
```
## 😊 二叉树: 从前序与中序遍历序列构造二叉树

- [leetcode原题](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

### 思路

由前序遍历可以得到根节点的值(数组中的第一个), 我们使用根节点的值分割中序遍历的数组。我们可以得到中序遍历左子树和中序遍历右子树。使用中序遍历左子树和中序遍历右子树的长度，分割前序遍历的数组可以得到前序遍历左子树和前序遍历右子树。然后接着递归分割即可。
### 解答

```js
/**
 * @param {number[]} preorder
 * @param {number[]} inorder
 * @return {TreeNode}
 */
 var buildTree = function(preorder, inorder) {

    const root = {
        val: null,
        left: null,
        right: null,
    }

    // 构建二叉树
    const construct = (preorder, inorder, node) => {
        if (preorder.length) {
            const left = {
                val: null,
                left: null,
                right: null,
            }

            const right = {
                val: null,
                left: null,
                right: null,
            }

            const root = preorder[0]
            const rootIndex = inorder.findIndex((val) => val === root)
            const inorderLeftTree = inorder.slice(0, rootIndex)
            const inorderRightTree = inorder.slice(rootIndex + 1)
            const inorderLeftTreeLen = inorderLeftTree.length
            const inorderRightTreeLen = inorderRightTree.length
            const preorderLeftTree = preorder.slice(1, inorderLeftTreeLen + 1)
            const preorderRightTree = preorder.slice(inorderLeftTreeLen + 1)
            
            node.val = preorder[0]
            node.left = inorderLeftTreeLen ? left : null
            node.right = inorderRightTreeLen ? right : null

            construct(preorderLeftTree, inorderLeftTree, left)
            construct(preorderRightTree, inorderRightTree, right)
        }
    }

    construct(preorder, inorder, root)

    return root;
};
```

## 😊 二叉树: 从中序与后序遍历序列构造二叉树

- [leetcode原题](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

### 思路

思路和上题类似, 这里不在赘述
### 解答

```js
/**
 * @param {number[]} inorder
 * @param {number[]} postorder
 * @return {TreeNode}
 */
var buildTree = function(inorder, postorder) {
    const root = {
        val: null,
        left: null,
        right: null,
    }

    const construct = (inorder, postorder, node) => {
        if (postorder.length) {
            const left = {
                val: null,
                left: null,
                right: null,
            }

            const right = {
                val: null,
                left: null,
                right: null,
            }

            const root = postorder[postorder.length - 1]
            const rootIndex = inorder.findIndex((val) => val === root)
            const inorderLeftTree = inorder.slice(0, rootIndex)
            const inorderRightTree = inorder.slice(rootIndex + 1)
            const inorderLeftTreeLen = inorderLeftTree.length
            const inorderRightTreeLen = inorderRightTree.length
            const postorderLeftTree = postorder.slice(0, inorderLeftTreeLen)
            const postorderRightTree = postorder.slice(inorderLeftTreeLen, postorder.length - 1)

            node.val = root
            node.left = inorderLeftTreeLen ? left : null
            node.right = inorderRightTreeLen ? right : null

            construct(inorderLeftTree, postorderLeftTree, left)
            construct(inorderRightTree, postorderRightTree, right)
        }
    }

    construct(inorder, postorder, root)

    return root;
};
```

## 😊 二叉树: 二叉树的最大深度  

- [leetcode原题](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)
### 思路

深度优先遍历二叉树，同时记录最大深度即可。（广度优先应该也可以，没有做尝试）
### 解答

```js
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {
    let max = 0

    const traverside = (node, depth) => {
        if (node) {
            max = Math.max(max, depth)
            traverside(node.left, depth + 1)
            traverside(node.right, depth + 1)
        }
    }

    traverside(root, 1)

    return max
};
```

## 😊 二叉树: 二叉树的最小深度   

- [leetcode原题](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)
### 思路

使用广度优先遍历，找到第一个没有子节点的子节点，当前的层级就是最小深度
### 解答

```js
/**
 * @param {TreeNode} root
 * @return {number}
 */
var minDepth = function(root) {
    let min = Number.MAX_VALUE

    const traverside = (nodes, depth) => {
        if (nodes.length) {
            const childs = []
            for (let i = 0; i < nodes.length; i += 1) {
                const node = nodes[i]
                if (node.left) {
                    childs.push(node.left)
                }
                if (node.right) {
                    childs.push(node.right)
                }
                if (!node.left && !node.right) {
                    // 没有子节点的节点
                    min = Math.min(depth, min)
                    // 终止遍历
                    return
                }
            }
            traverside(childs, depth + 1)
        }
    }

    if (root) {
        traverside([root], 1)
    } else {
        return 0
    }

    return min
};
```

## 😊 二叉树: 二叉树的最近公共祖先

- [leetcode原题](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

### 思路

遍历二叉树，同时使用`map`记录每一个节点的父节点。然后使用遍历`p`的所有父节点，并记录。之后遍历`q`, 查找`q`的父节点是否在`p`的父节点记录中。
### 解答

```js
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */
 var lowestCommonAncestor = function(root, p, q) {
    if (p === q) return p
    if (p === root.val || q === root.val) return root.val

    const map = new Map()
    const parents = new Set()
    let result = null

    // 遍历二叉树, 记录每一个节点的父节点
    const traverside = (node) => {
        if (node) {
            if (node.left) {
                map.set(node.left, node)
            }
            if (node.right) {
                map.set(node.right, node)
            }
            traverside(node.left)
            traverside(node.right)
        }
    }
    map.set(root, null)
    traverside(root)

    while (p !== null) {
        parents.add(p)
        p = map.get(p)
    }

    while (q !== null) {
        if (parents.has(q)) {
            result = q
            break
        }
        q = map.get(q)
    }

    return result
};
```

## 😊 二叉树: 对称二叉树

- [leetcode原题](https://leetcode-cn.com/problems/symmetric-tree/)

### 思路

遍历二叉树，但是同时从两个方向遍历，镜像比较`val`值是否相等。
### 解答

```js
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
 var isSymmetric = function(root) {
    let result = true

    const traverside = (left, right) => {
        if (left && right) {
            const leftVal = left.val
            const rightVal = right.val
            if (leftVal === rightVal) {
                traverside(left.left, right.right)
                traverside(left.right, right.left)
            } else {
                result = false
            }
        } else {
            if (left || right) {
                result = false 
            }
        }
    }

    traverside(root, root)

    return result
};
```
## 😊 二叉树: 平衡二叉树

- [leetcode原题](https://leetcode-cn.com/problems/balanced-binary-tree/)

### 思路

### 解答

```js
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
 var isBalanced = function(root) {
    if (!root) return true

    let result = true

    // 获取节点高的
    const getDepth = (node) => {
        if (node) {
            return Math.max(getDepth(node.left), getDepth(node.right)) + 1
        } else {
            return 0
        }
    }

    const traverside = (node) => {
        if (node) {
            const leftNode = node.left
            const rightNode = node.right
            const leftDepth = getDepth(leftNode, 0)
            const rightDepth = getDepth(rightNode, 0)
            if (Math.abs(rightDepth - leftDepth) <= 1) {
                // 左右子节点继续向下查找
                traverside(leftNode)
                traverside(rightNode)
            } else {
                result = false
                return
            }
        }
    }

    traverside(root)

    return result
};
```

## 😊 二叉树: 翻转二叉树

- [leetcode原题](https://leetcode-cn.com/problems/invert-binary-tree/)

### 思路

### 解答

```js
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
 var invertTree = function(root) {
    const traverside = (node) => {
        if (node) {
            const left = node.left
            const right = node.right
            traverside(left)
            traverside(right)
            node.left = right
            node.right = left
        }
    }

    traverside(root, root)

    return root
};
```

## 😊 二叉树: 二叉树的右视图

- [leetcode原题](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

### 思路

层序遍历即可, 然后获取每一层遍历的最后一个值
### 解答

```js
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var rightSideView = function(root) {
    if (!root) return []

    const result = []

    const traverside = (nodes) => {
        const len = nodes.length
        if (len) {
            const childs = []
            for (let i = 0; i < len; i += 1) {
                const node = nodes[i]
                if (i === len - 1) {
                    result.push(node.val)
                }
                if (node.left) {
                    childs.push(node.left)
                }
                if (node.right) {
                    childs.push(node.right)
                }
            }
            traverside(childs)
        }
    }

    traverside([root])

    return result
};
```

## 😊 二叉树: 二叉树的锯齿形层序遍历

- [leetcode原题](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/)

### 思路

层序遍历判断每一层的奇偶即可
### 解答

```js
var zigzagLevelOrder = function(root) {
    if (!root) return []

    const result = []

    const traverside = (nodes, level) => {
        const len = nodes.length
        if (len) {
            const childs = []
            const vals = []
            for (let i = 0; i < len; i += 1) {
                const node = nodes[i]
                vals.push(node.val)
                if (node.left) {
                    childs.push(node.left)
                }
                if (node.right) {
                    childs.push(node.right)
                }
            }
            if ((level & 1) === 0) {
                // 偶数
                vals.reverse()
            }
            result.push(vals)
            traverside(childs, level + 1)
        }
    }

    traverside([root], 1)

    return result
};
```
## 😊 二叉树: 路径总和

- [leetcode原题](https://leetcode-cn.com/problems/path-sum/)

### 思路


### 解答

```js
/**
 * @param {TreeNode} root
 * @param {number} targetSum
 * @return {boolean}
 */
var hasPathSum = function(root, targetSum) {
    if (!root) return false

    let result = false

    const traverside = (node, sum) => {
        if (node) {
            sum += node.val
            if (!node.left && !node.right) {
                // 说明是叶子节点
                if (sum === targetSum) {
                    result = true
                    return
                }
            } else {
                traverside(node.left, sum)
                traverside(node.right, sum)
            }
        }
    }

    traverside(root, 0)

    return result
};
```

## 😊 二叉树: 路径总和 II

- [leetcode原题](https://leetcode-cn.com/problems/path-sum-ii/)

### 思路


### 解答

```js
/**
 * @param {TreeNode} root
 * @param {number} targetSum
 * @return {number[][]}
 */
var pathSum = function(root, targetSum) {
    if (!root) return []

    const result = []

    const traverside = (node, arr, sum) => {
        if (node) {
            sum += node.val
            arr.push(node.val)
            if (!node.left && !node.right) {
                // 说明是叶子节点
                if (sum === targetSum) {
                    result.push(arr)
                }
            } else {
                traverside(node.left, [...arr], sum)
                traverside(node.right, [...arr], sum)
            }
        }
    }

    traverside(root, [], 0)

    return result
};
```
## 😊 二叉树: 二叉树展开为链表

## 😊 二叉树: 完全二叉树的节点个数

## 😊 二叉树: 验证二叉搜索树

- [leetcode原题](https://leetcode-cn.com/problems/validate-binary-search-tree/)

### 思路

使用中序遍历。中序遍历是先遍历左子树，然后访问根节点，然后遍历右子树。如果是二叉搜索树，结果是一个递增的数组

### 解答

```js
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isValidBST = function(root) {
    if (!root) return false

    const vals = []

    const traverside = (node) => {
        if (node) {
            traverside(node.left)
            vals.push(node.val)
            traverside(node.right)
        }
    }

    traverside(root)

    const before = vals.join(',')
    const after = [...new Set(vals.sort((a, b) => a - b))].join(',')
    
    return before === after
};
```

## 😊 二叉树: 删除二叉搜索树中的节点

## 😊 二叉树: 二叉搜索树中的搜索

## 😊 哈希: 两数之和

## 😊 哈希: 三数之和

## 😊 哈希: 四数之和

## 😊 栈: 括号是否有效

## 😊 栈: 最小栈

## 😊 栈: 用栈实现队列

## 😊 栈: 简化路径

## 😊 二分搜索: x的平方根

## 😊 二分搜索: 在排序数组中查找元素的第一个和最后一个位置

## 😊 链表: 反转链表

## 😊 链表: 环形链表

## 😊 链表: 排序链表

## 😊 链表: 回文链表

## 😊 链表: 合并两个有序链表

## 😊 链表: 排序链表

## 😊 动态规划: 求一个数组最大子项的和，要求这些子项在数组中的位置不是连续的

## 😊 动态规划: 爬楼梯 & 斐波那契数

## 😊 堆: 数组中的第K个最大元素

## 😊 双指针: 无重复字符的最长子串


## 😊 双指针: 盛最多水的容器
## 😊 双指针: 最长公共前缀

## 😊 双指针: 寻找两个正序数组的中位数

## 😊 前缀和: 和为K的子数组

## 😊 前缀树: 实现Trie树

## 😊 前缀树: 单词替换

## 😊 DFS: 岛屿的最大面积

## 😊 DFS: 相同的树

## 😊 BFS: 二叉树的最小深度


## 😊 分治: 多数元素

## 😊 回溯: N皇后

## 😊 回溯: 全排列

## 😊 回溯: 组合

## 😊 回溯: 括号生成

## 😊 回溯: 复原IP地址

## 😊 回溯: 子集

## 😊 贪心: 跳跃游戏

## 😊 动态规划: 最大子序和

## 😊 动态规划: 零钱兑换


## 😊 动态规划: 最长递增子序列


## 😊 动态规划: 不同路径

## 😊 字符串: 大数相加

## 😊 字符串: 比较版本号


## 😊 数组: 最大子序和
## 😊 数组: 求数组里面最大连续子项的和

## 😊 数组: 不相交的线

## 😊 数组: 找到所有数组中消失的数字

## 😊 数组: 环形子数组的最大和

## 😊 数组: 环形子数组的最大和

## 😊 数组: 螺旋矩阵

## 😊 数组: 螺旋矩阵 II

## 😊 字符串: 有效的括号字符串

## 😊 数学: 分数加减运算

## 😊 数学: 整数反转

## 😊 甲板上的战舰
