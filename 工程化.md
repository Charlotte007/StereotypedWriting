## 😊 说一说前端异常如何监控

### 错误的捕获的方式

- `onerror`, `onerror`可以捕获到宏任务抛出的错误。而`Promise`和`async`函数抛出的错误是捕获不到的。
- `window.addEventListener('error', () => {}, true)`, 由于资源请求异常不会冒泡，只有在捕获阶段才能获取到。可以使用`window.addEventListener`设置为捕获阶段触发，用来捕获资源请求的错误。（需要注意判断event.target, 避免和`onerror`重复监听）
- `onunhandledrejection`, `onunhandledrejection`可以捕获微任务中的错误。但是没有错误行和列等位置信息。（不推荐直接使用，建议自己主动上报，可以对请求库进行封装，发生错误时自动上报）。
- `try…catch`, 无法捕获到异步中的错误(微任务, 以及`setTimeout`)中的错误。并且`try…catch`也无法捕获语法错误。

#### React

React可以使用**错误边界**组件对UI做降级处理。使用`static getDerivedStateFromError()`降级UI。`componentDidCatch`用于上报错误。
#### 一些常见的问题

- Script error。对于本域的js抛出的错误，onerror包含了详情的错误信息。对于其他域的js抛出的错误，只会在msg中显示简单的 Script error。可以在script标签上添加，crossorigin属性，静态文件服务器开启CORS。

### 错误信息格式化

不同浏览器错误信息格式可能不同。可以使用`tracekit`库对错误信息格式化。
### 错误的上报

1. ajax上报错误
2. 使用gif图上报错误
### 定位外网错误位置

线上的代码都是混淆压缩的，无法直接定位源码中的错误。可以使用SourceMap中的mappings属性还原源码。在发布时，可以在内网保存SourceMap文件，使用`https://github.com/mozilla/source-map`这个库定位错误。

> https://github.com/BengBu-YueZhang/trashcan-broom，接错误信息结合SourceMap文件定位错误的代码。

## 😊 说一说前端的性能指标，以及性能监控
### 前端性能指标

> Long Tasks, 长任务，指的所有执行时间超过50ms的任务

- FCP，从页面开始加载到屏幕上呈现页面内容（任意部分）的时间。任意部分指：文本，图像，背景图片，svg和非空白的canvas元素。
- TTI，从页面开始加载开始到其主要的子资源加载完毕之间的时间。TTI能判断页面是否可以快速的响应用户的输入。TTI的计算过程:
  1. 从FCP开始。
  2. 从FCP向后查找是否有5s的静默窗口，静默窗口的定义是: 没有长任务，处于pending中的GET请求不超过2个。
  3. 从静默窗口开始向前查找查找，查找到的第一个长任务的。如果找不到长任务，则到FCP为止。
  4. TTI的时间，是静默窗口向前查找到第一个长任务的结束的时间。如果没有长任务，则是FCP的时间。
- LCP，从页面首次加载，到窗口中可见最大图像和文本块的时间。
  - 最大内容包含了img元素，video元素，包含背景图片的元素，或者包含文本的块级元素
- FID，用户第一次与页面进行交互（点击按钮）到浏览器响应交互的时间。
- TBT，测量了从FCP到TTI之间的所有长任务时长的总和。
- CLS，页面整个生命周期中发生的每个意外的版式移位分数的总和。

下面指标不推荐使用：

- FMP, 首次有效绘制时间，FMP衡量用户何时可以看到页面的主要内容。该指标的定义依赖于特定于浏览器的实现细节，这意味着它不能在所有Web浏览器中标准化或实现。目前使用LCP代替。

### 如何监控这些指标?

## 😊 说一说前端页面秒开优化

## 了解过lerna吗

## 😊 说一说组件库按需引入的原理

## 😊 说一说CommonJS, AMD, UMD, ES6模块的差异

## 😊 埋点为什么使用gif
