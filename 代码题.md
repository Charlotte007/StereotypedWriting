## 1. å®ç°curry

> https://bigfrontend.dev/zh/problem/implement-curry

```js
const join = (a, b, c) => {
   return `${a}_${b}_${c}`
}

const curriedJoin = curry(join)

curriedJoin(1, 2, 3) // '1_2_3'

curriedJoin(1)(2, 3) // '1_2_3'

curriedJoin(1, 2)(3) // '1_2_3'

// å®ç°curry
const curry = (fn, ...initParams) => {
  return (...args) => {
    return ((params) => {
      return params.length >= fn.length ? fn(...params) : curry(fn, ...params) 
    })([ ...initParams, ...args])
  }
}
```

## 2. å®ç°æ”¯æŒplaceholderçš„curry()

> https://bigfrontend.dev/zh/problem/implement-curry-with-placeholder

```ts
/**
 * åˆå¹¶å‚æ•°ï¼ˆæ›¿æ¢å ä½ç¬¦ï¼‰
 */
function merge(params1, params2) {
  for (let i = 0; i < params1.length; i += 1) {
    if (params2.length) {
      if (typeof params1[i] === 'symbol') {
        const first = params2.shift()
        params1[i] = first
      }
    } else {
        break
    }
  }
  return [...params1, ...params2]
}

/**
 * @param { (...args: any[]) => any } fn
 * @returns { (...args: any[]) => any }
 */
function curry(fn, ...initParams) {
  return (...args) => {
    const params = merge([...initParams], [...args])
    return ((params) => {
      params = params.slice(0, fn.length)
      // åˆ¤æ–­æ˜¯å¦å¯ä»¥æ‰§è¡Œ
      const isCall = params.filter((item) => typeof item !== 'symbol').length >= fn.length
      return isCall ? fn(...params) : curry(fn, ...params) 
    })(params)
  }
}

curry.placeholder = Symbol()
```

## 3. å®ç°Array.prototype.flat()

> https://bigfrontend.dev/zh/problem/implement-Array-prototype.flat

```js
/**
 * @param { Array } arr
 * @param { number } depth
 * @returns { Array }
 */
function flat(arr, depth = 1) {
  const result = []
  if (depth) {
    let isExistArray = false;
    for (let i = 0; i < arr.length; i += 1) {
      const item = arr[i]
      if (Array.isArray(item)) {
        isExistArray = true
        result.push(...item)
      } else {
        result.push(item)
      }
    }
    if (isExistArray) {
      return flat(result, depth - 1)
    } else {
      return result
    }
  } else {
    return arr
  }
}
```

## 4. æ‰‹å†™throttle()

> https://bigfrontend.dev/zh/problem/implement-basic-throttle

```ts
/**
 * @param {Function} func
 * @param {number} wait
 */
function throttle(func, wait) {
  let timer
  let lastArgs
  return function (...param) {
    if (!timer) {
      func.call(this, ...param)
      timer = window.setTimeout(() => {
        lastArgs && func.call(this, ...lastArgs)
        lastArgs = null
        timer = null
      }, wait)
    } else {
      lastArgs = [...param]
    }
  }
}
```

## 6. æ‰‹å†™debounce()

> https://bigfrontend.dev/zh/problem/implement-basic-debounce

```ts
/**
 * @param {Function} func
 * @param {number} wait
 */
function debounce(func, wait) {
  let timer
  return function (...param) {
    function clear() {
      window.clearTimeout(timer)
      timer = null
    }
    function run() {
      timer = window.setTimeout(() => {
        func.call(this, ...param)
        clear()
      }, wait)
    }
    if (!timer) {
      run()
    } else {
      clear()
      run()
    }
  }
}
```


## 8. æ‰‹å†™shuffle()éšæœºæ‰“ä¹±ä¸€ä¸ªæ•°ç»„ï¼ˆå®ç°ä¸€ä¸ªæ´—ç‰Œç®—æ³•ï¼‰

> https://bigfrontend.dev/zh/problem/can-you-shuffle-an-array

> å¸¸è§„çš„`const randomIndex = Math.floor(Math.random() * arr.length)`ç”Ÿæˆéšæœºç´¢å¼•çš„æ–¹å¼ä¸å¤Ÿéšæœº

```js
/**
  * @param {any[]} arr
  */
function shuffle(arr) {
  for (let i = 0; i < arr.length; i += 1) {
    const j = i + Math.floor(Math.random() * (arr.length - 1));
    [arr[i], arr[j]] = [arr[j], arr[i]]
  }
  return arr
}
```

## 9. è§£å¯†æ¶ˆæ¯

> https://bigfrontend.dev/zh/problem/decode-message

```ts
/**
 * @param {string[][]} message
 * @return {string}
 */
function decode(message) {
  // ä¸ºç©ºçš„åˆ¤æ–­
  if (!message.length || !message[0].length) {
    return ''
  }

  let power = true
  let str = ''
  let i = 0
  let j = 0
  let direction = 'LowerRight' // LowerRight | UpperRight
  let w = message[0].length
  let h = message.length

  function lowerRight() {
    if (i + 1 < h && j + 1 < w) {
      i = i + 1
      j = j + 1
    } else {
      if (i - 1 > 0 && j + 1 < w) {
        direction = 'UpperRight'
        i = i - 1
        j = j + 1
      } else {
        power = false
      }
    }
  }

  function upperRight() {
    if (i - 1 > 0 && j + 1 < w) {
      i = i - 1
      j = j + 1
    } else {
      if (i + 1 < h && j + 1 < w) {
        direction = 'LowerRight'
        i = i + 1
        j = j + 1
      } else {
        power = false
      }
    }
  }

  while (power) {
    str += message[i][j]
    if (direction === 'LowerRight') {
      lowerRight()
    } else if (direction === 'UpperRight') {
      upperRight()
    }
  }
  return str
}
```
## 10. æ‰¾å‡ºç¬¬ä¸€ä¸ªä¸è‰¯ç‰ˆæœ¬

> https://bigfrontend.dev/zh/problem/first-bad-version

> ç®€å•çš„äºŒåˆ†æŸ¥æ‰¾

```ts
/*
 type TypIsBad = (version: number) => boolean
 */

/**
 * @param {TypIsBad} isBad 
 */
function firstBadVersion(isBad) {
  return (version) => {
    let start = 0
    let end = version
    let result = isBad(version) ? version : -1

    while (end >= start) {
      let midd = Math.floor((start + end) / 2)
      if (isBad(midd)) {
        // å¦‚æœæ˜¯åçš„
        end = midd - 1
        result = midd
      } else {
        // å¦‚æœæ˜¯å¥½çš„
        start = midd + 1
      }
    }
    return result
  }
}
```

## 11. ä»€ä¹ˆæ˜¯Composition?å®ç°pipe()

> https://bigfrontend.dev/zh/problem/what-is-composition-create-a-pipe

> å®ç°ä¸€ä¸ªç®¡é“å‡½æ•°

```ts
/**
 * @param {Array<(arg: any) => any>} funcs 
 * @return {(arg: any) => any}
 */
function pipe(funcs) {
	return function (arg) {
		let param = arg
		for (let i = 0; i < funcs.length; i += 1) {
			const func = funcs[i]
			param = func(param)
		}
		return param
	}
}
```

## 12. å®ç° Immutability helper

> https://bigfrontend.dev/zh/problem/implement-Immutability-helper

> Reactæ–‡æ¡£: https://reactjs.org/docs/update.html

> æœ‰ç‚¹éš¾è¿™é¢˜ğŸ˜…

```ts
/**
 * @param {any} data
 * @param {Object} command
 */
function update(data, command) {
  const collection = {$push: true, $set: true, $merge: true, $apply: true}

  const handlePush = function (command, keys) {
    let arr = data
    for (let i = 0; i < keys.length; i += 1) {
      arr = arr[keys[i]]
    }
    if (Array.is)
  }

  const handleSet = function () {
  }

  const handleMerge = function () {
  }

  const handleApply = function () {
  }

  const job = function (keys, command) {
    for (let key in command) {
      if (collection[key]) {
        switch (key) {
          case '$push':
            handlePush(command[key], keys)
            break
          case '$set':
            break
          case '$merge':
            break
          case '$apply':
            break
        }
      } else {
        job([...keys, key], command.key)
      }
    }
  }

  job([], command)

  return {...data}
}
```

## 13. åˆ©ç”¨æ ˆ(Stack)åˆ›å»ºé˜Ÿåˆ—(Queue)

> https://bigfrontend.dev/zh/problem/implement-a-queue-by-using-stack

> å¯ä»¥ç”¨ä¸¤ä¸ªStackå®ç°Queue

> æ›´ç®€å•çš„æ–¹æ³•æ˜¯ï¼Œæ¯ä¸€æ¬¡enqueueæ—¶éƒ½åç€å­˜

```ts

class Stack {
  constructor () {
    this.stack = []
  }
  push(element) {
    this.stack.push(element)
  }
  peek() {
    return this.stack[this.stack.length - 1]
  }
  pop() {
    return this.stack.pop()
  }
  size() {
    return this.stack.length
  }
}

// ä½¿ç”¨Stackå®ç°Queue
class Queue {
  constructor () {
    this.enqueueStack = new Stack()
    this.dequeueStack = new Stack()
  }

  _enqueueSyncDequeue () {
    const dequeueTemp = new Stack()
    const enqueueTemp = new Stack()
    while (this.enqueueStack.size()) {
      const p = this.enqueueStack.pop()
      dequeueTemp.push(p)
      enqueueTemp.push(p)
    }
    while (enqueueTemp.size()) {
      this.enqueueStack.push(enqueueTemp.pop())
    }
    this.dequeueStack = dequeueTemp
  }

  _dequeueSyncEnqueue () {
    const dequeueTemp = new Stack()
    const enqueueTemp = new Stack()
    while (this.dequeueStack.size()) {
      const p = this.dequeueStack.pop()
      dequeueTemp.push(p)
      enqueueTemp.push(p)
    }
    while (dequeueTemp.size()) {
      this.dequeueStack.push(dequeueTemp.pop())
    }
    this.enqueueStack = enqueueTemp
  }

  enqueue(element) { 
    this.enqueueStack.push(element)
    this._enqueueSyncDequeue()
  }

  peek() { 
    return this.dequeueStack.peek()
  }
  
  dequeue() {
    const p = this.dequeueStack.pop()
    this._dequeueSyncEnqueue()
    return p
  }

  size() { 
    return this.enqueueStack.size()
  }
}
```

## 14. å®ç°`memo()`

> https://bigfrontend.dev/zh/problem/implement-general-memoization-function

```ts
/**
 * @param {Function} func
 * @param {(args:[]) => string }  [resolver] - cache key generator
 */
function memo(func, resolver) {
  const map = new Map();
  return function (...params) {
    let key
    if (typeof resolver === 'function') {
      key = resolver(...params)
    } else {
      key = [...params].join('-')
    }
    if (map.has(key)) {
      return map.get(key)
    } else {
      const val = func.apply(this, [...params])
      map.set(key, val)
      return val
    }
  }
}
```
## 15. å®ç°ç±»ä¼¼jQueryçš„DOM wrapper

> https://bigfrontend.dev/zh/problem/implement-a-simple-DOM-wrapper-to-support-method-chaining-like-jQuery

```ts
```

## 16. å®ç°ä¸€ä¸ªEvent Emitter

> https://bigfrontend.dev/zh/problem/create-an-Event-Emitter

```ts
```

## 21. æ‰‹å†™JSON.stringify()

> https://bigfrontend.dev/zh/problem/implement-JSON-stringify

```ts
```

## 22. æ‰‹å†™JSON.parse()

> https://bigfrontend.dev/zh/problem/implement-JSON-parse

```ts
```
## 23. å®ç°ä¸€ä¸ªsum()æ–¹æ³•

> https://bigfrontend.dev/zh/problem/create-a-sum

```ts
/**
 * @param {number} num
 */
function sum(num) {
  const fn = function (arg) {
    return sum(num + arg)
  }
  fn.toString = function () {
    return num
  }
  return fn
}
```

## 25. æ›´æ–°æ•°ç»„çš„é¡ºåº

> https://bigfrontend.dev/zh/problem/reorder-array-with-new-indexes

```js
/**
 * @param {any[]} items
 * @param {number[]} newOrder
 * @return {void}
 */
// ä¸å®ç”¨é¢å¤–ç©ºé—´
function sort(items, newOrder) {
  // ä½¿ç”¨ç®€å•çš„å†’æ³¡æ’åº
  for (let i = 0; i < items.length; i += 1) {
    for (let j = i + 1; j < items.length; j += 1) {
      if (newOrder[i] > newOrder[j]) {
        // æ›´æ–°itemsçš„é¡ºåºä»¥åŠnewOrderçš„é¡ºåº
        let otemp = newOrder[j]
        let itemp = items[j]
        newOrder[j] = newOrder[i]
        newOrder[i] = otemp
        items[j] = items[i]
        items[i] = itemp
      }
    }
  }
  return items
}
```

## 97. å‹ç¼©å­—ç¬¦ä¸²

> https://bigfrontend.dev/zh/problem/compress-a-string

```js
/**
 * @param {string} str
 * @return {string}
 */
function compress(str) {
  let s = str[0]
  let p = str[0]
  let n = 1

  for (let i = 1; i < str.length; i += 1) {
    if (str[i] === p) {
      n += 1
      if (n > 2) {
        let arr = s.split('')
        arr.pop()
        s = `${arr.join('')}${n}`
      } else {
        s = `${s}${n}`
      }
    } else {
      p = str[i]
      n = 1
      s = `${s}${str[i]}`
    }
  }

  return s
}
```


## å®ç°`Promise.all()`

> https://bigfrontend.dev/zh/problem/implement-Promise-all

```ts
/**
 * @param {Array<any>} promises - notice input might have non-Promises
 * @return {Promise<any[]>}
 */
function all(promises) {
  return new Promise((resolve, reject) => {
    if (!promises.length) {
      return resolve([])
    }
    const result = [];
    let count = 0;
    for (let i = 0; i < promises.length; i++) {
      const promise = promises[i] instanceof Promise ? promises[i] : Promise.resolve(promises[i])
      promise.then((res) => {
        result[i] = res
        count += 1
        if (count === promises.length) {
          resolve(result)
        }
      }).catch((err) => {
        reject(err)
      })
    }
  })
}
```

## å®ç°`Promise.any()`

> https://bigfrontend.dev/zh/problem/implement-Promise-any

```ts
/**
 * @param {Array<Promise>} promises
 * @return {Promise}
 */
function any(promises) {
  return new Promise((resolve, reject) => {
    if (!promises.length) {
      return reject(
        new AggregateError(
          'No Promise in Promise.any was resolved', 
          []
        )
      )
    }
    const errors = [];
    let count = 0;
    for (let i = 0; i < promises.length; i += 1) {
      const promise = promises[i] instanceof Promise ? promises[i] : Promise.resolve(promises[i])
      promise.then((res) => {
        resolve(res)
      }).catch((err) => {
        errors[i] = err
        count += 1
        if (count === promises.length) {
          reject(
            new AggregateError(
              'No Promise in Promise.any was resolved', 
              errors
            )
          )
        }
      })
    }
  })
}
```
## å®ç°`Promise.allSettled()`

> https://bigfrontend.dev/zh/problem/implement-Promise-allSettled

```ts
/**
 * @param {Array<any>} promises - notice that input might contains non-promises
 * @return {Promise<Array<{status: 'fulfilled', value: any} | {status: 'rejected', reason: any}>>}
 */
function allSettled(promises) {
  return new Promise((resolve, reject) => {
    if (!promises.length) {
      return resolve([])
    }
    const result = [];
    let count = 0;
    for (let i = 0; i < promises.length; i++) {
      const promise = promises[i] instanceof Promise ?
        promises[i] :
        Promise.resolve(promises[i])
      promise.then((res) => {
        result[i] = {status:"fulfilled",value: res}
        count += 1
        if (count === promises.length) {
          resolve(result)
        }
      }).catch((err) => {
        result[i] = {status:"rejected",reason: err}
        count += 1
        if (count === promises.length) {
          resolve(result)
        }
      })
    }
  })
}
```

## å®ç°`Promise.race()`

> https://bigfrontend.dev/zh/problem/implement-Promise-race

```ts
/**
 * @param {Array<Promise>} promises
 * @return {Promise}
 */
function race(promises) {
  return new Promise((resolve, reject) => {
    if (promises.length) {
      for (let i = 0; i < promises.length; i += 1) {
        const promise = promises[i] instanceof Promise ?
          promises[i]
          :
          Promise.resolve(promises[i])
        promise.then((res) => {
          resolve(res)
        }).catch((err) => {
          reject(err)
        })
      }
    }
  })
}
```
## ğŸœèš‚èšé‡‘æœé¢è¯•çœŸé¢˜: å®ç°compose

```js
function f(next) {console.log(1);next();console.log(2);}
function g(next) {console.log(3);next();console.log(4);}
function h(next) {console.log(5);next();console.log(6);}


// å®ç°compose
function compose(...funcs) {
  if (funcs.length === 0) {
    return arg => arg 
  }
  if (funcs.length === 1) {
    return funcs[0]
  }
  return function () {
    return funcs.reduce((a,b) => {
      return (next) => a(() => {
        b(next)
      })
    })(() => {})
  }
}

// 1,3,5,6,4,2
// ç¬¬ä¸€æ¬¡è¿”å›(next) => f(() => g(next)ï¼‰
// ç¬¬äºŒæ¬¡a: (next) => f(() => g(next)ï¼‰ b: h
// ç¬¬äºŒæ¬¡è¿”å› (next) => ï¼ˆ(next) => f(() => g(next))(() => h(next))
// (next) =>f(() => g(() => h(next)))
compose(f,g,h)(() => {})
```

