## 1. 实现curry

> https://bigfrontend.dev/zh/problem/implement-curry

```js
const join = (a, b, c) => {
   return `${a}_${b}_${c}`
}

const curriedJoin = curry(join)

curriedJoin(1, 2, 3) // '1_2_3'

curriedJoin(1)(2, 3) // '1_2_3'

curriedJoin(1, 2)(3) // '1_2_3'

// 实现curry
const curry = (fn, ...initParams) => {
  return (...args) => {
    return ((params) => {
      return params.length >= fn.length ? fn(...params) : curry(fn, ...params) 
    })([ ...initParams, ...args])
  }
}
```

## 2. 实现支持placeholder的curry()

> https://bigfrontend.dev/zh/problem/implement-curry-with-placeholder

```ts
/**
 * 合并参数（替换占位符）
 */
function merge(params1, params2) {
  for (let i = 0; i < params1.length; i += 1) {
    if (params2.length) {
      if (typeof params1[i] === 'symbol') {
        const first = params2.shift()
        params1[i] = first
      }
    } else {
        break
    }
  }
  return [...params1, ...params2]
}

/**
 * @param { (...args: any[]) => any } fn
 * @returns { (...args: any[]) => any }
 */
function curry(fn, ...initParams) {
  return (...args) => {
    const params = merge([...initParams], [...args])
    return ((params) => {
      params = params.slice(0, fn.length)
      // 判断是否可以执行
      const isCall = params.filter((item) => typeof item !== 'symbol').length >= fn.length
      return isCall ? fn(...params) : curry(fn, ...params) 
    })(params)
  }
}

curry.placeholder = Symbol()
```

## 3. 实现Array.prototype.flat()

> https://bigfrontend.dev/zh/problem/implement-Array-prototype.flat

```js
/**
 * @param { Array } arr
 * @param { number } depth
 * @returns { Array }
 */
function flat(arr, depth = 1) {
  const result = []
  if (depth) {
    let isExistArray = false;
    for (let i = 0; i < arr.length; i += 1) {
      const item = arr[i]
      if (Array.isArray(item)) {
        isExistArray = true
        result.push(...item)
      } else {
        result.push(item)
      }
    }
    if (isExistArray) {
      return flat(result, depth - 1)
    } else {
      return result
    }
  } else {
    return arr
  }
}
```

## 4. 手写throttle()

> https://bigfrontend.dev/zh/problem/implement-basic-throttle

```ts
/**
 * @param {Function} func
 * @param {number} wait
 */
function throttle(func, wait) {
  let timer
  let lastArgs
  return function (...param) {
    if (!timer) {
      func.call(this, ...param)
      timer = window.setTimeout(() => {
        lastArgs && func.call(this, ...lastArgs)
        lastArgs = null
        timer = null
      }, wait)
    } else {
      lastArgs = [...param]
    }
  }
}
```

## 6. 手写debounce()

> https://bigfrontend.dev/zh/problem/implement-basic-debounce

```ts
/**
 * @param {Function} func
 * @param {number} wait
 */
function debounce(func, wait) {
  let timer
  return function (...param) {
    function clear() {
      window.clearTimeout(timer)
      timer = null
    }
    function run() {
      timer = window.setTimeout(() => {
        func.call(this, ...param)
        clear()
      }, wait)
    }
    if (!timer) {
      run()
    } else {
      clear()
      run()
    }
  }
}
```


## 8. 手写shuffle()随机打乱一个数组（实现一个洗牌算法）

> https://bigfrontend.dev/zh/problem/can-you-shuffle-an-array

> 常规的`const randomIndex = Math.floor(Math.random() * arr.length)`生成随机索引的方式不够随机

```js
/**
  * @param {any[]} arr
  */
function shuffle(arr) {
  for (let i = 0; i < arr.length; i += 1) {
    const j = i + Math.floor(Math.random() * (arr.length - 1));
    [arr[i], arr[j]] = [arr[j], arr[i]]
  }
  return arr
}
```

## 9. 解密消息

> https://bigfrontend.dev/zh/problem/decode-message

```ts
/**
 * @param {string[][]} message
 * @return {string}
 */
function decode(message) {
  // 为空的判断
  if (!message.length || !message[0].length) {
    return ''
  }

  let power = true
  let str = ''
  let i = 0
  let j = 0
  let direction = 'LowerRight' // LowerRight | UpperRight
  let w = message[0].length
  let h = message.length

  function lowerRight() {
    if (i + 1 < h && j + 1 < w) {
      i = i + 1
      j = j + 1
    } else {
      if (i - 1 > 0 && j + 1 < w) {
        direction = 'UpperRight'
        i = i - 1
        j = j + 1
      } else {
        power = false
      }
    }
  }

  function upperRight() {
    if (i - 1 > 0 && j + 1 < w) {
      i = i - 1
      j = j + 1
    } else {
      if (i + 1 < h && j + 1 < w) {
        direction = 'LowerRight'
        i = i + 1
        j = j + 1
      } else {
        power = false
      }
    }
  }

  while (power) {
    str += message[i][j]
    if (direction === 'LowerRight') {
      lowerRight()
    } else if (direction === 'UpperRight') {
      upperRight()
    }
  }
  return str
}
```
## 10. 找出第一个不良版本

> https://bigfrontend.dev/zh/problem/first-bad-version

> 简单的二分查找

```ts
/*
 type TypIsBad = (version: number) => boolean
 */

/**
 * @param {TypIsBad} isBad 
 */
function firstBadVersion(isBad) {
  return (version) => {
    let start = 0
    let end = version
    let result = isBad(version) ? version : -1

    while (end >= start) {
      let midd = Math.floor((start + end) / 2)
      if (isBad(midd)) {
        // 如果是坏的
        end = midd - 1
        result = midd
      } else {
        // 如果是好的
        start = midd + 1
      }
    }
    return result
  }
}
```

## 11. 什么是Composition?实现pipe()

> https://bigfrontend.dev/zh/problem/what-is-composition-create-a-pipe

> 实现一个管道函数

```ts
/**
 * @param {Array<(arg: any) => any>} funcs 
 * @return {(arg: any) => any}
 */
function pipe(funcs) {
	return function (arg) {
		let param = arg
		for (let i = 0; i < funcs.length; i += 1) {
			const func = funcs[i]
			param = func(param)
		}
		return param
	}
}
```

## 😭 12. 实现 Immutability helper

> https://bigfrontend.dev/zh/problem/implement-Immutability-helper

> React文档: https://reactjs.org/docs/update.html

> 有点难这题😅

```ts
/**
 * @param {any} data
 * @param {Object} command
 */
function update(data, command) {
  const collection = {$push: true, $set: true, $merge: true, $apply: true}

  const handlePush = function (command, keys) {
    let arr = data
    for (let i = 0; i < keys.length; i += 1) {
      arr = arr[keys[i]]
    }
    if (Array.is)
  }

  const handleSet = function () {
  }

  const handleMerge = function () {
  }

  const handleApply = function () {
  }

  const job = function (keys, command) {
    for (let key in command) {
      if (collection[key]) {
        switch (key) {
          case '$push':
            handlePush(command[key], keys)
            break
          case '$set':
            break
          case '$merge':
            break
          case '$apply':
            break
        }
      } else {
        job([...keys, key], command.key)
      }
    }
  }

  job([], command)

  return {...data}
}
```

## 13. 利用栈(Stack)创建队列(Queue)

> https://bigfrontend.dev/zh/problem/implement-a-queue-by-using-stack

> 可以用两个Stack实现Queue

> 更简单的方法是，每一次enqueue时都反着存。

```ts

class Stack {
  constructor () {
    this.stack = []
  }
  push(element) {
    this.stack.push(element)
  }
  peek() {
    return this.stack[this.stack.length - 1]
  }
  pop() {
    return this.stack.pop()
  }
  size() {
    return this.stack.length
  }
}

// 使用Stack实现Queue
class Queue {
  constructor () {
    this.enqueueStack = new Stack()
    this.dequeueStack = new Stack()
  }

  _enqueueSyncDequeue () {
    const dequeueTemp = new Stack()
    const enqueueTemp = new Stack()
    while (this.enqueueStack.size()) {
      const p = this.enqueueStack.pop()
      dequeueTemp.push(p)
      enqueueTemp.push(p)
    }
    while (enqueueTemp.size()) {
      this.enqueueStack.push(enqueueTemp.pop())
    }
    this.dequeueStack = dequeueTemp
  }

  _dequeueSyncEnqueue () {
    const dequeueTemp = new Stack()
    const enqueueTemp = new Stack()
    while (this.dequeueStack.size()) {
      const p = this.dequeueStack.pop()
      dequeueTemp.push(p)
      enqueueTemp.push(p)
    }
    while (dequeueTemp.size()) {
      this.dequeueStack.push(dequeueTemp.pop())
    }
    this.enqueueStack = enqueueTemp
  }

  enqueue(element) { 
    this.enqueueStack.push(element)
    this._enqueueSyncDequeue()
  }

  peek() { 
    return this.dequeueStack.peek()
  }
  
  dequeue() {
    const p = this.dequeueStack.pop()
    this._dequeueSyncEnqueue()
    return p
  }

  size() { 
    return this.enqueueStack.size()
  }
}

// 改进版
class Queue {
  constructor () {
    this.stack = new Stack()
    this.queue = new Stack()
  }

  enqueue(element) { 
    while (this.queue.size()) {
      this.stack.push(this.queue.pop())
    }
    this.queue.push(element)
    while (this.stack.size()) {
      this.queue.push(this.stack.pop())
    }
  }

  peek() { 
    return this.queue.peek()
  }
  
  dequeue() {
    return this.queue.pop()
  }

  size() { 
    return this.queue.size()
  }
}
```

## 14. 实现`memo()`

> https://bigfrontend.dev/zh/problem/implement-general-memoization-function

```ts
/**
 * @param {Function} func
 * @param {(args:[]) => string }  [resolver] - cache key generator
 */
function memo(func, resolver) {
  const map = new Map();
  return function (...params) {
    let key
    if (typeof resolver === 'function') {
      key = resolver(...params)
    } else {
      key = [...params].join('-')
    }
    if (map.has(key)) {
      return map.get(key)
    } else {
      const val = func.apply(this, [...params])
      map.set(key, val)
      return val
    }
  }
}
```
## 15. 实现类似jQuery的DOM wrapper

> https://bigfrontend.dev/zh/problem/implement-a-simple-DOM-wrapper-to-support-method-chaining-like-jQuery

```ts

/**
 * @param {HTMLElement} el - element to be wrapped
 */
function $(el) {
  el.css = function (key, value) {
    el.style[key] = value
    return el
  }

  return el
}
```

## 16. 实现一个Event Emitter

> https://bigfrontend.dev/zh/problem/create-an-Event-Emitter

```ts
// please complete the implementation
class EventEmitter {
  constructor () {
    this.map = {}
  }

  subscribe(eventName, callback) {
    const event = {eventName, callback}
    const that = this
    if (this.map[eventName]) {
      this.map[eventName].push(event)
    } else {
      this.map[[eventName]] = [event]
    }

    return {
      release () {
        that.map = {
          ...that.map,
          [eventName]: that.map[eventName].filter((e) => e !== event)
        }
      }
    }
  }
  
  emit(eventName, ...args) {
  	if (this.map[eventName]) {
      this.map[eventName].forEach((event) => {
        const { callback } = event
        callback(...args)
      })
    }
  }
}
```

## 17. 实现一个DOM element store

> https://bigfrontend.dev/zh/problem/create-a-simple-store-for-DOM-node

> 注意时间空间复杂度,has方法的时间复杂度应该是o(1)

> 如何实现一个Map polyfill

```ts
class NodeStore {
  constructor () {
    this.map = {}
  }

  /**
  * @param {Node} node
  * @param {any} value
  */
  set(node, value) {
    if (!node.__mapKey__) {
      node.__mapKey__ = Symbol()
      this.map[node.__mapKey__] = value
    } else {
      this.map[node.__mapKey__] = value
    }
  }

 /**
  * @param {Node} node
  * @return {any}
  */
  get(node) {
    return this.map[node.__mapKey__]
  }
 
 /**
  * @param {Node} node
  * @return {Boolean}
  */
 has(node) {
   return !!node.__mapKey__ && node.__mapKey__ in this.map
 }
}
```

## 18. 优化一个function

> https://bigfrontend.dev/zh/problem/improve-a-function


优化前的时间复杂度O(m * n)

```ts
// items是一个array
// 包含的元素有 >=3 个属性

let items = [
  {color: 'red', type: 'tv', age: 18}, 
  {color: 'silver', type: 'phone', age: 20},
  {color: 'blue', type: 'book', age: 17}
] 

// 一个由key和value组成的array
const excludes = [ 
  {k: 'color', v: 'silver'}, 
  {k: 'type', v: 'tv'}, 
  ...
] 

function excludeItems(items, excludes) { 
  excludes.forEach( pair => { 
    items = items.filter(item => item[pair.k] === item[pair.v])
  })
 
  return items
} 
```

优化后：

```ts
function excludeItems(items, excludes) { 
  const excludesMap = {}
  excludes.forEach(({k, v}) => {
    if (excludesMap[k]) {
      excludesMap[k].add(v)
    } else {
      excludesMap[k] = new Set()
      excludesMap[k].add(v)
    }
  })

  return items.filter((item) => {
    return Object.keys(item).every((key) => {
      if (excludesMap[key]) {
        return !excludesMap[key].has(item[key])
      }
      return true
    })
  })
} 
```

## 19. 相同结构的DOM tree上面寻找对应的节点

> https://bigfrontend.dev/zh/problem/find-corresponding-node-in-two-identical-DOM-tree

```ts
/**
 * @param {HTMLElement} rootA
 * @param {HTMLElement} rootB - rootA and rootB are clone of each other
 * @param {HTMLElement} nodeA
 */
const findCorrespondingNode = (rootA, rootB, target) => {
  const paths = []
  let isSearchEnd = false
  let targetB = rootB

  const find = (node, index) => {
    if (index !== undefined && !isSearchEnd) {
      paths.push(index)
    }
    if (node !== target) {
      const children = [...node.children]
      children.forEach((item, index) => {
        find(item, index)
      })
      if (!isSearchEnd) {
        paths.pop()
      }
    } else {
      isSearchEnd = true
    }
  }

  find(rootA)

  if (paths.length !== 0) {
    while (paths.length) {
      const index = paths.shift()
      targetB = [...targetB.children][index]
    }
  }

  return targetB
}
```

## 20. 检测 data type

> https://bigfrontend.dev/zh/problem/detect-data-type-in-JavaScript

```ts
/**
 * @param {any} data
 * @return {string}
 */
function detectType(data) {
  if(data instanceof FileReader) {
    return 'object'
  }
  const type = Object.prototype.toString.call(data);
  return /^\[object\s+([A-Za-z]+)\]$/.exec(type)[1].toLocaleLowerCase()
}
```

## 😭 21. 手写JSON.stringify()

> https://bigfrontend.dev/zh/problem/implement-JSON-stringify

```ts
```

## 😭 22. 手写JSON.parse()

> https://bigfrontend.dev/zh/problem/implement-JSON-parse

```ts
```
## 23. 实现一个sum()方法

> https://bigfrontend.dev/zh/problem/create-a-sum

```ts
/**
 * @param {number} num
 */
function sum(num) {
  const fn = function (arg) {
    return sum(num + arg)
  }
  fn.toString = function () {
    return num
  }
  return fn
}
```

## 24. 用JavaScript手写一个Priority Queue

> https://bigfrontend.dev/zh/problem/create-a-priority-queue-in-JavaScript

```ts

// complete the implementation
class PriorityQueue {
  /**
   * @param {(a: any, b: any) => -1 | 0 | 1} compare - 
   * compare function, similar to parameter of Array.prototype.sort
   */
  constructor(compare) {
    this.compare = compare;
  }

  /**
   * return {number} amount of items
   */
  size() {

  }

  /**
   * returns the head element
   */
  peek() {

  }

  /**
   * @param {any} element - new element to add
   */
  add(element) {
   
  }

  /**
   * remove the head element
   * @return {any} the head element
   */
  poll() {
    
  }
}
```
## 25. 更新数组的顺序

> https://bigfrontend.dev/zh/problem/reorder-array-with-new-indexes

```js
/**
 * @param {any[]} items
 * @param {number[]} newOrder
 * @return {void}
 */
// 不实用额外空间
function sort(items, newOrder) {
  // 使用简单的冒泡排序
  for (let i = 0; i < items.length; i += 1) {
    for (let j = i + 1; j < items.length; j += 1) {
      if (newOrder[i] > newOrder[j]) {
        // 更新items的顺序以及newOrder的顺序
        let otemp = newOrder[j]
        let itemp = items[j]
        newOrder[j] = newOrder[i]
        newOrder[i] = otemp
        items[j] = items[i]
        items[i] = itemp
      }
    }
  }
  return items
}

```

## 26. 实现Object.assign()

> https://bigfrontend.dev/zh/problem/implement-object-assign

```ts
/**
 * @param {any} target
 * @param {any[]} sources
 * @return {object}
 */
 function objectAssign(target, ...sources) {
  if (target === null || target === undefined) {
    throw new Error()
  } 
  if (typeof target === 'number') {
    target = new Number(target)
  }
  if (typeof target === 'boolean') {
    target = new Boolean(target)
  }
  if (typeof target === 'string') {
    target = new String(target)
  }
  sources.forEach(source => {
    if (source === undefined || source === null) {
      return
    }
    Object.defineProperties(
      target,
      Object.getOwnPropertyDescriptors(source)
    )
  })
  return target
}
```

## 27. 实现completeAssign()

> https://bigfrontend.dev/zh/problem/implement-completeAssign

> https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty

```ts
function completeAssign(target, ...sources) {
  if (target === null || target === undefined) {
    throw new Error()
  } 
  if (typeof target === 'number') {
    target = new Number(target)
  }
  if (typeof target === 'boolean') {
    target = new Boolean(target)
  }
  if (typeof target === 'string') {
    target = new String(target)
  }
  sources.forEach(source => {
    if (source === undefined || source === null) {
      return
    }
    Object.defineProperties(
      target,
      Object.getOwnPropertyDescriptors(source)
    )
  })
  return target
}
```

## 28. 实现clearAllTimeout()

> https://bigfrontend.dev/zh/problem/implement-clearAllTimeout

```ts
const beforeSetTimeout = window.setTimeout

window.timers = new Set()

// 重写setTimeout
window.setTimeout = function (handler, timeout, ...arg) {
  const that = this
  const timer = beforeSetTimeout(
    function (...arg) {
      handler.apply(that, [...arg])
    },
    timeout,
    ...arg
  )
  window.timers.add(timer)
  return timer
}


/**
 * cancel all timer from window.setTimeout
 */
function clearAllTimeout() {
  window.timers.forEach((timer) => {
    window.clearTimeout(timer)
  })
}
```

## 29. 实现async helper - `sequence()`

> https://bigfrontend.dev/zh/problem/implement-async-helper-sequence

```ts
/*
type Callback = (error: Error, data: any) => void

type AsyncFunc = (
   callback: Callback,
   data: any
) => void
*/

function promisify(func) {
  return function (num) {
    return new Promise(function(resolve, reject) {
      func(function (err, data) {
        if (err) {
          reject(err)
        } else {
          resolve(data)
        }
      }, num)
    })
  }
}

/**
 * @param {AsyncFunc[]} funcs
 * @return {(callback: Callback) => void}
 */
function sequence(funcs) {
  funcs = funcs.map(func => promisify(func))
  return async function (callback, data) {
    try {
      for (let i = 0; i < funcs.length; i += 1) {
        data = await funcs[i](data)
      }
      callback(undefined, data)
    } catch (error) {
      callback(error, undefined)
    }
  }
}
```

## 30. 实现async helper - `parallel()`

> https://bigfrontend.dev/zh/problem/implement-async-helper-parallel

```ts
/*
type Callback = (error: Error, data: any) => void

type AsyncFunc = (
   callback: Callback,
   data: any
) => void

*/

function promisify(func) {
  return function (...args) {
    return new Promise(function(resolve, reject) {
      func(function (err, data) {
        if (err) {
          reject(err)
        } else {
          resolve(data)
        }
      }, ...args)
    })
  }
}

/**
 * @param {AsyncFunc[]} funcs
 * @return {(callback: Callback) => void}
 */
function parallel(funcs){
  funcs = funcs.map(func => promisify(func))
  return function (callback, data) {
    let count = 0
    let handleError = false
    const result = []
    for (let i = 0; i < funcs.length; i += 1) {
      funcs[i](data).then(function (res) {
        result[i] = res
        count += 1
        if (count === funcs.length) {
          callback(undefined, result)
        }
      }).catch(function (err) {
        if (!handleError) {
          callback(err, undefined)
          handleError = true
        }
      })
    }
  }
}
```

## 31. 实现async helper - `race()`

> https://bigfrontend.dev/zh/problem/implement-async-helper-race

```ts
/*
type Callback = (error: Error, data: any) => void

type AsyncFunc = (
   callback: Callback,
   data: any
) => void

*/
function promisify(func) {
  return function (...args) {
    return new Promise(function(resolve, reject) {
      func(function (err, data) {
        if (err) {
          reject(err)
        } else {
          resolve(data)
        }
      }, ...args)
    })
  }
}

/**
 * @param {AsyncFunc[]} funcs
 * @return {(callback: Callback) => void}
 */
function race(funcs){
  funcs = funcs.map(func => promisify(func))
  return function (callback, data) {
    let handleEnd = false
    for (let i = 0; i < funcs.length; i += 1) {
      funcs[i](data).then(function (res) {
        if (!handleEnd) {
          callback(undefined, res)
        }
        handleEnd = true
      }).catch(function (err) {
        if (!handleEnd) {
          callback(err, undefined)
        }
        handleEnd = true
      })
    }
  }
}
```

## 32. 实现`Promise.all()`

> https://bigfrontend.dev/zh/problem/implement-Promise-all

```ts
/**
 * @param {Array<any>} promises - notice input might have non-Promises
 * @return {Promise<any[]>}
 */
function all(promises) {
  return new Promise((resolve, reject) => {
    if (!promises.length) {
      return resolve([])
    }
    const result = [];
    let count = 0;
    for (let i = 0; i < promises.length; i++) {
      const promise = promises[i] instanceof Promise ? promises[i] : Promise.resolve(promises[i])
      promise.then((res) => {
        result[i] = res
        count += 1
        if (count === promises.length) {
          resolve(result)
        }
      }).catch((err) => {
        reject(err)
      })
    }
  })
}
```
## 33. 实现`Promise.allSettled()`

> https://bigfrontend.dev/zh/problem/implement-Promise-allSettled

```ts
/**
 * @param {Array<any>} promises - notice that input might contains non-promises
 * @return {Promise<Array<{status: 'fulfilled', value: any} | {status: 'rejected', reason: any}>>}
 */
function allSettled(promises) {
  return new Promise((resolve, reject) => {
    if (!promises.length) {
      return resolve([])
    }
    const result = [];
    let count = 0;
    for (let i = 0; i < promises.length; i++) {
      const promise = promises[i] instanceof Promise ?
        promises[i] :
        Promise.resolve(promises[i])
      promise.then((res) => {
        result[i] = {status:"fulfilled",value: res}
        count += 1
        if (count === promises.length) {
          resolve(result)
        }
      }).catch((err) => {
        result[i] = {status:"rejected",reason: err}
        count += 1
        if (count === promises.length) {
          resolve(result)
        }
      })
    }
  })
}
```
## 34. 实现`Promise.any()`

> https://bigfrontend.dev/zh/problem/implement-Promise-any

```ts
/**
 * @param {Array<Promise>} promises
 * @return {Promise}
 */
function any(promises) {
  return new Promise((resolve, reject) => {
    if (!promises.length) {
      return reject(
        new AggregateError(
          'No Promise in Promise.any was resolved', 
          []
        )
      )
    }
    const errors = [];
    let count = 0;
    for (let i = 0; i < promises.length; i += 1) {
      const promise = promises[i] instanceof Promise ? promises[i] : Promise.resolve(promises[i])
      promise.then((res) => {
        resolve(res)
      }).catch((err) => {
        errors[i] = err
        count += 1
        if (count === promises.length) {
          reject(
            new AggregateError(
              'No Promise in Promise.any was resolved', 
              errors
            )
          )
        }
      })
    }
  })
}
```


## 35. 实现`Promise.race()`

> https://bigfrontend.dev/zh/problem/implement-Promise-race

```ts
/**
 * @param {Array<Promise>} promises
 * @return {Promise}
 */
function race(promises) {
  return new Promise((resolve, reject) => {
    if (promises.length) {
      for (let i = 0; i < promises.length; i += 1) {
        const promise = promises[i] instanceof Promise ?
          promises[i]
          :
          Promise.resolve(promises[i])
        promise.then((res) => {
          resolve(res)
        }).catch((err) => {
          reject(err)
        })
      }
    }
  })
}
```

## 36. 实现一个 fake timer(setTimeout)

> https://bigfrontend.dev/zh/problem/create-a-fake-timer

```ts
```

## 37. 手写Binary Search (unique)

> https://bigfrontend.dev/zh/problem/implement-Binary-Search-Unique

```ts
```

## 38. 实现`jest.spyOn()`

> https://bigfrontend.dev/zh/problem/implement-spyOn

```ts
/**
 * @param {object} obj
 * @param {string} methodName
 */
function spyOn(obj, methodName) {
  if (!(obj[methodName] instanceof Function)) {
    throw new Error()
  }

  const before = obj[methodName]
  const calls = []

  obj[methodName] = function (...args) {
    calls.push([...args])
    before.call(this, ...args)
  }

  return {
    calls
  }
}
```

## 39. 手写range()

> https://bigfrontend.dev/zh/problem/implement-range

```ts
/**
 * @param {integer} from
 * @param {integer} to
 */
function range(from, to) {
  const result = []
  while (from <= to) {
    result.push(from)
    from += 1
  }
  return result
}
```

## 40. 手写冒泡排序

> https://bigfrontend.dev/zh/problem/implement-Bubble-Sort

> 冒泡排序，属于稳定的排序，空间复杂度O(n), 时间复杂度O(n^2)。稳定的排序指的是不会改变元素的相对位置

```ts
/**
 * @param {number[]} arr
 */
 function bubbleSort(arr) {
  for (let i = 0; i < arr.length; i += 1) {
    for (let j = i + 1; j < arr.length; j += 1) {
      if (arr[i] > arr[j]) {
        [arr[i], arr[j]] = [arr[j], arr[i]]
      }
    }
  }
  return arr
}
```

## 41. 手写归并排序

> https://bigfrontend.dev/zh/problem/implement-Merge-Sort

> 分治法，归并排序是稳定的排序，时间复杂度是 O(nlogn)

> 参考文章：https://stackabuse.com/merge-sort-in-javascript

```ts
// Note: 需要直接在原数组上修改
function merge (left, right) {
  const arr = []
  while (left.length && right.length) {
    if (left[0] > right[0]) {
      arr.push(right.shift())
    } else {
      arr.push(left.shift())
    }
  }
  return [...arr, ...left, ...right]
}

/**
 * @param {number[]} arr
 */
function mergeSort(arr) {
  if (arr.length <= 1) {
    return arr
  }

  const midd = Math.floor(arr.length / 2)
  const left = arr.splice(0, midd)

  return merge(mergeSort(left), mergeSort(arr))
}

// 原地修改
// 递归最外层的right就是原数组
function merge (left, right) {
  const arr = []
  while (left.length && right.length) {
    if (left[0] > right[0]) {
      arr.push(right.shift())
    } else {
      arr.push(left.shift())
    }
  }

  while (arr.length) {
    right.unshift(arr.pop())
  }

  if (left.length) {
    right.push(left.pop())
  }

  return right
}

/**
 * @param {number[]} arr
 */
function mergeSort(arr) {
  if (arr.length <= 1) {
    return arr
  }

  const midd = Math.floor(arr.length / 2)
  const left = arr.splice(0, midd)

  return merge(mergeSort(left), mergeSort(arr))
}
```

## 42. 手写插入排序

> https://bigfrontend.dev/zh/problem/implement-Insertion-Sort

> 插入排序是稳定的排序，时间复杂度是O(n^2)

```ts
/**
 * @param {number[]} arr
 */
function insertionSort(arr) {
  for (let i = 0; i < arr.length; i += 1) {
    for (let j = i + 1; j < arr.length; j += 1) {
      if (arr[i] > arr[j]) {
        const item = arr.splice(j,1)[0]
        arr.splice(i,0,item)
      }
    }
  }

  return arr
}
```

## 43. 手写快速排序

> https://bigfrontend.dev/zh/problem/implement-Quick-Sort

> 快速排序是不稳定的排序，最坏的情况时间复杂度是O(n^2)。平均的时间复杂度是O(nlogn) 

```ts
// Note: 需要直接在原数组上修改
/**
 * @param {number[]} arr
 */
function quickSort(arr) {
  if (arr.length <= 1) {
    return arr
  }

  const referenceValue = arr[0]
  const max = []
  const min = []

  for (let i = 1; i < arr.length; i += 1) {
    if (arr[i] >= referenceValue) {
      max.push(arr[i])
    } else {
      min.push(arr[i])
    }
  }

  return quickSort(min).concat(referenceValue, quickSort(max))
}

// 原地修改
/**
 * @param {number[]} arr
 */
function quickSort(arr) {
  if (arr.length <= 1) {
    return arr
  }

  const referenceValue = arr[0]
  let max = []
  let min = []

  for (let i = 1; i < arr.length; i += 1) {
    if (arr[i] >= referenceValue) {
      max.push(...arr.splice(i,1))
    } else {
      min.push(...arr.splice(i,1))
    }
    i -= 1
  }

  min = quickSort(min)
  max = quickSort(max)

  while (max.length) {
    arr.push(max.shift())
  }

  while (min.length) {
    arr.unshift(min.pop())
  }

  return arr
}
```

## 44. 手写选择排序

> https://bigfrontend.dev/zh/problem/implement-Selection-Sort

> https://www.geeksforgeeks.org/selection-sort/

> 选择排序是不稳定排序，时间复杂度是O(n^2)

```ts
/**
 * @param {number[]} arr
 */
function selectionSort(arr) {
  for (let i = 0; i < arr.length; i += 1) {
    let minIndex = i
    for (let j = i + 1; j < arr.length; j += 1) {
      if (arr[j] < arr[minIndex]) {
        minIndex = j
      }
    }
    const min = arr.splice(minIndex, 1)[0]
    arr.splice(i, 0, min)
  }
  return arr
}
```

## 45. 在未排序的数组中找到第K大的元素

> https://bigfrontend.dev/zh/problem/find-the-K-th-largest-element-in-an-unsorted-array

```ts
// 分治

/**
 * @param {number[]} arr
 * @param {number} k
 */
function findKThLargest(arr, k) {
  let result

  const divideAndConquer = (arr, base) => {
    if (arr.length <= 1) {
      result = arr[0]
    }
    const min = []
    const max = []
    let maxLen
    const referenceValue = arr[0]
    for (let i = 1; i < arr.length; i += 1) {
      if (arr[i] > referenceValue) {
        max.push(arr[i])
      } else {
        min.push(arr[i])
      }
    }
    max.push(arr[0])
    maxLen = max.length + base
    if (maxLen >= k && max.length) {
      divideAndConquer(max, base)
    } else if (maxLen < k && min.length) {
      divideAndConquer(min, maxLen)
    }
  }

  divideAndConquer(arr, 0)

  return result
}
```

## 46. 实现`_.once()`

> https://bigfrontend.dev/zh/problem/implement-once

```ts
/**
 * @param {Function} func
 * @return {Function}
 */
function once(func) {
  let result
  let once = true
  return function (...args) {
    if (once) {
      result = func.call(this, ...args)
      once = false
    }
    return result
  }
}
```

## 47. 反转链表

> https://bigfrontend.dev/zh/problem/Reverse-a-linked-list

## 53. 实现middleware

> https://bigfrontend.dev/zh/problem/create-a-middleware-system

```ts
```

### 🐜蚂蚁金服面试真题: 实现compose

```js
function f(next) {console.log(1);next();console.log(2);}
function g(next) {console.log(3);next();console.log(4);}
function h(next) {console.log(5);next();console.log(6);}


// ((next) => {
//   ((next) => {
//     return f(() => {
//       g(next)
//     })
//   })(() => { h(next) })
// })(() => {
//   console.log('ok')
// })

// f(() => {
//   g(() => {
//     h(() => {
//     })
//   })
// })

// 实现compose
function compose(...funcs) {
  if (funcs.length === 0) {
    return arg => arg 
  }
  if (funcs.length === 1) {
    return funcs[0]
  }
  return function () {
    return funcs.reduce((a,b) => {
      return (next) => {
        return a(() => {
          b(next)
        })
      }
    })(() => {})
  }
}

// 1,3,5,6,4,2
// 第一次返回(next) => f(() => g(next)）
// 第二次a: (next) => f(() => g(next)） b: h
// 第二次返回 (next) => （(next) => f(() => g(next))(() => h(next))
// (next) =>f(() => g(() => h(next)))
compose(f,g,h)()
```

## 53. 用es5实现`extends`

> https://bigfrontend.dev/zh/problem/write-your-own-extends-in-es5

```ts
const myExtends = (SuperType, SubType) => {
  function Child (...args) {
    SuperType.call(this, ...args)
    SubType.call(this, ...args)
    // 这里Child其实本质还是SubType，还是这里要修改下
    Object.setPrototypeOf(this, SubType.prototype)
  }

  SubType.prototype = Object.create(SuperType.prototype)
  Child.prototype = Object.create(SubType.prototype)

  SubType.prototype.constructor = SubType
  Child.prototype.constructor = Child

  // 模拟es6额外的继承链
  Object.setPrototypeOf(Child, SuperType)

  return Child
}
```

## 😭 54. 扁平化Thunk

> https://bigfrontend.dev/zh/problem/flatten-Thunk

## 55. HTML字符串中高亮关键字

> https://bigfrontend.dev/zh/problem/highlight-keywords-in-HTML-string

```ts
// 获取所有关键词的排列组合
/**
 * @param {string} html
 * @param {string[]} keywords
 */
function highlightKeywords(html, keywords) {
  const combination = []
  let arr = html.split(' ')

  const getCombination = (head, arr) => {
    for (let i = 0; i < arr.length; i += 1) {
      const temp = [...arr]
      temp.splice(i, 1)
      const name = `${head}${arr[i]}`
      combination.push(name)
      getCombination(name, temp)
    }
  }

  getCombination('', keywords)

  arr = arr.map((item) => {
    if (combination.includes(item)) {
      return `<em>${item}</em>`
    } else if (keywords.some((keyword) => item.includes(keyword))) {
      for (let i = 0; i < keywords.length; i += 1) {
        const keyword = keywords[i]
        if (item.includes(keyword)) {
          const reg = new RegExp(keyword, 'g')
          item = item.replace(reg, `<em>${keyword}</em>`)
          break
        }
      }
      return item
    } else {
      return item
    }
  })

  return arr.join(' ')
};

// 单纯的使用正则
```

## 😭 57. 实现Observable

> https://bigfrontend.dev/zh/problem/create-an-Observable

```ts
```

## 58. 返回DOM tree的高度

> https://bigfrontend.dev/zh/problem/get-DOM-tree-height

## 59. 实现browser history

> https://bigfrontend.dev/zh/problem/create-a-browser-history

```ts
```

## 60. 实现自己的`new`

> https://bigfrontend.dev/zh/problem/create-your-own-new-operator

```ts
/**
 * @param {Function} constructor
 * @param {any[]} args - argument passed to the constructor
 * `myNew(constructor, ...args)` should return the same as `new constructor(...args)`
 */
const myNew = (constructor, ...args) => {
  const obj = {}
  const returnValue = constructor.call(obj, ...args)
  Object.setPrototypeOf(obj, constructor.prototype)
  return returnValue || obj
}
```
## 61. 实现`Function.prototype.call`

> https://bigfrontend.dev/zh/problem/create-call-method

```ts
Function.prototype.mycall = function(thisArg, ...args) {
  if (thisArg === undefined || thisArg === null) {
    thisArg = window
  }
  if (typeof thisArg === 'string') {
    thisArg = new String(thisArg)
  }
  if (typeof thisArg === 'number') {
    thisArg = new Number(thisArg)
  }
  if (typeof thisArg === 'boolean') {
    thisArg = new Boolean(thisArg)
  }
  const key = Symbol()
  thisArg[key] = this
  const result = thisArg[key](...args)
  delete thisArg[key]
  return result
}
```

### 手写apply


### 手写bind
## 63. 手写`_.cloneDeep()`

> https://bigfrontend.dev/zh/problem/create-cloneDeep

```ts
// 规避循环引用 Avoid circular references
const hash = new WeakMap()

function isObject(value) {
  return value != null && (typeof value === "object" || typeof value === "function")
}

function getSymbolKeys(value) {
  let keys = Object.getOwnPropertySymbols(value)
  keys = keys.filter((key) => value.propertyIsEnumerable(key))
  return keys
}

function getAllKeys(value) {
  let keys = Object.keys(value)
  keys = [...keys, ...getSymbolKeys(value)]
  return keys
}

function cloneDeep(data) {
  let result = null

  if (!isObject(data)) {
    return data
  }

  const isArray = Array.isArray(data)

  if (isArray) {
    result = []
  } else {
    result = Object.create(Object.getPrototypeOf(data))
  }

  if (hash.has(data)) {
    return hash.get(data)
  } else {
    hash.set(data, result)
  }

  const keys = getAllKeys(data)

  for (let i = 0; i < keys.length; i += 1) {
    const key = keys[i]
    const val = data[key]
    result[key] = cloneDeep(val)
  }

  return result
}
```

## 64. Promise reject的时候自动retry

> https://bigfrontend.dev/zh/problem/retry-promise-on-rejection

```js
/**
 * @param {() => Promise<any>} fetcher
 * @param {number} maximumRetryCount
 * @return {Promise<any>}
 */
function fetchWithAutoRetry(fetcher, maximumRetryCount) {
  return new Promise(async (resolve, reject) => {
    let error
    for (let i = 0; i <= maximumRetryCount; i += 1) {
      await fetcher().then((res) => {
        resolve(res)
      }).catch((err) => {
        error = err
      })
    }
    reject(error)
  })
}
```

## 65. 添加千位分隔符

> https://bigfrontend.dev/zh/problem/add-comma-to-number

```ts
/**
 * @param {number} num
 * @return {string}
 */
function addComma(num) {
  // your code here
}
```

## 69. 实现`_.isEqual()`

> https://bigfrontend.dev/zh/problem/implement-deep-equal-isEqual

## 81. 合并已排序的数组

> https://bigfrontend.dev/zh/problem/merge-sorted-arrays

## 83. 实现一个interval

> https://bigfrontend.dev/zh/problem/create-an-interval

## 85. 实现 `_.get()`

> https://bigfrontend.dev/zh/problem/implement-lodash-get

```ts
/**
 * @param {object} source
 * @param {string | string[]} path
 * @param {any} [defaultValue]
 * @return {any}
 */
function get(source, path, defaultValue = undefined) {
  if (typeof path === 'string') {
    path = path.split('.')
  }

  const newPath = []
  const reg = /^([A-Za-z]+)\[([0-9]+)]$/g
  let result = source

  for (let i = 0; i < path.length; i += 1) {
    if (path[i].includes('[')) {
      const arr = reg.exec(path[i])
      newPath.push(arr[1])
      newPath.push(arr[2])
    } else {
      newPath.push(path[i])
    }
  }

  for (let i = 0; i < newPath.length; i += 1) {
    if (result === undefined || result === null) {
      result = defaultValue
      break
    }
    result = result[newPath[i]]
  }

  console.log(result)

  return result ? result : defaultValue
}
```



## 87. 返回最长的不重复子字符串

> https://bigfrontend.dev/zh/problem/longest-substring-with-unique-characters
## 90. 实现`instanceof`

> https://bigfrontend.dev/zh/problem/write-your-own-instanceof

```ts
/**
 * @param {any} obj
 * @param {target} target
 * @return {boolean}
 */
function myInstanceOf(obj, target) {
  if (typeof obj !== 'object' || obj === null) {
    return false
  }
  const proto = Object.getPrototypeOf(obj)
  if (proto === null) {
    return false
  }
  if (proto === target.prototype) {
    return true
  } else {
    return myInstanceOf(proto, target)
  }
}
```

## 91. 反转二叉树

> https://bigfrontend.dev/zh/problem/invert-a-binary-tree

```ts
/**
 * @param {Node} node
 * @returns {Node}
 */
function invert(node) {
  if (!node) return null

  const traverside = (node) => {
    if (node) {
      const left = node.left
      const right = node.right
      node.right = left
      node.left = right
      traverside(left)
      traverside(right)
    }
  }

  traverside(node)

  return node
}
```

## 92. Promise节流

> https://bigfrontend.dev/zh/problem/throttle-Promises

```ts
/**
 * @param {() => Promise<any>} func
 * @param {number} max
 * @return {Promise}
 */
function throttlePromises(funcs, max){
  return new Promise(function (resolve, reject) {
    const result = []
    const len = funcs.length
    let jobs = 0
    let count = 0

    const handleJobs = () => {
      while (jobs < max && funcs.length) {
        let promise = funcs.shift()()
        let index = len - funcs.length - 1
        promise = promise instanceof Promise ? promise : Promise.resolve(promise)
        promise.then((res) => {
          result[index] = res
          count += 1
          jobs -= 1
          if (count === len) {
            resolve(result)
          }
          handleJobs()
        }).catch((err) => {
          reject(err)
        })
        jobs += 1
      }
    }
    handleJobs()
  })
}
```
## 94. 实现`Object.create`

> https://bigfrontend.dev/zh/problem/implement-your-own-Object-create

```ts
/**
 * @param {any} proto
 * @return {object}
 */
function myObjectCreate(proto) {
  if (!(proto instanceof Object)) {
    throw new Error()
  }
  const obj = {}
  obj.__proto__ = proto
  return obj
}

/**
 * @param {any} proto
 * @return {object}
 */
function myObjectCreate(proto) {
  if (!(proto instanceof Object)) {
    throw new Error()
  }
  function Constructor () {}
  Constructor.prototype = proto
  return new Constructor();
}

// Error
// ES6的class语法无法修改类的Constructor.prototype
// https://stackoverflow.com/questions/37680766/how-to-change-classs-prototype-in-es6
/**
 * @param {any} proto
 * @return {object}
 */
function myObjectCreate(proto) {
  if (!(proto instanceof Object)) {
    throw new Error()
  }
  class Constructor {}
  Constructor.prototype = proto
  return new Constructor();
}
```

## 95. 实现 String.prototype.trim()

> https://bigfrontend.dev/zh/problem/implement-String-prototype-trim

```js
/**
 * @param {string} str
 * @return {string}
 */
function trim(str) {
  return str.replace(/^\s+|\s+$/g, '')
}
```
## 97. 压缩字符串


> https://bigfrontend.dev/zh/problem/compress-a-string

```js
/**
 * @param {string} str
 * @return {string}
 */
function compress(str) {
  let s = str[0]
  let p = str[0]
  let n = 1

  for (let i = 1; i < str.length; i += 1) {
    if (str[i] === p) {
      n += 1
      if (n > 2) {
        let arr = s.split('')
        arr.pop()
        s = `${arr.join('')}${n}`
      } else {
        s = `${s}${n}`
      }
    } else {
      p = str[i]
      n = 1
      s = `${s}${str[i]}`
    }
  }

  return s
}
```

## 98. 检测合法IP地址

> https://bigfrontend.dev/zh/problem/validate-an-ip-address

## 99. 在HTML字符串中抽出所有的<a/>

> https://bigfrontend.dev/zh/problem/extract-all-anchor-elements-from-HTML-string

```ts
/**
 * @param {string} str
 * @return {string[]}
 */
function extract(str) {
  const result = []
  // (\s[^>]*)?, 如果有[^>]，就必须有空格
  // [^>]也包括了空格
  const reg = /<a(\s[^>]*)?>.*?<\s*\/\s*a>/g
  let controller = true

  while (controller) {
    const match = reg.exec(str)
    if (match) {
      result.push(match[0])
    } else {
      controller = false
    }
  }

  return result
}
```

## 100. 检测链表中是否有环

> https://bigfrontend.dev/zh/problem/detect-circle-in-linked-list

## 101. 合并相同的API请求

> https://bigfrontend.dev/zh/problem/merge-identical-API-calls

## 102. 验证括号字符串

> https://bigfrontend.dev/zh/problem/validate-parenthesis

```js
class Stack {
  constructor () {
    this.stack = []
    Object.defineProperties(this, {
      size: {
        set () {
          throw new Error()
        },
        get () {
          return this.stack.length
        }
      }
    })
  }

  push (n) {
    this.stack.push(n)
  }

  pop () {
    return this.stack.pop()
  }

  peek () {
    return this.stack[this.stack.length - 1]
  }
}

/**
 * @param {string} str
 * @return {boolean} 
 */
function validate(str) {
  const stack = new Stack()
  for (let i = 0; i < str.length; i += 1) {
    if (stack.size === 0) {
      stack.push(str[i])
    } else {
      const top = stack.peek()
      if (top === '[' && str[i] === ']') {
        stack.pop()
        continue
      } else if (top === '{' && str[i] === '}') {
        stack.pop()
        continue
      } else if (top === '(' && str[i] === ')') {
        stack.pop()
        continue
      } else {
        stack.push(str[i])
      }
    }
  }
  return stack.size === 0 ? true : false
}
```


## 103. 实现Math.sqrt()

> https://bigfrontend.dev/zh/problem/implement-Math-sqrt

> 使用二分法

```ts
/**
 * @param {any} x
 * @return {number}
 */
function mySqrt(x) {
  if (!(typeof x === "number" && !isNaN(x) && x >= 0)) return NaN
  if (x === 0) return 0
  if (x === 1) return 1

  let result = null

  const sqrt = (start, end) => {
    if (start <= end) {
      const midd = Math.floor((end + start) / 2)
      if (midd ** 2 < x) {
        result = midd
        sqrt(midd + 1, end)
      } else if (midd ** 2 > x) {
        sqrt(start, midd - 1)
      } else {
        result = midd
      }
    }
  }

  sqrt(0, x)

  return result
}
```

## 104. 按层遍历DOM树

> https://bigfrontend.dev/zh/problem/Traverse-DOM-level-by-level

## 105. 找到第一个重复的字符

> https://bigfrontend.dev/zh/problem/find-the-first-duplicate-character-in-a-string

> 使用hash

```ts
/**
 * @param {string} str
 * @return {string | null}
 */
function firstDuplicate(str) {
  let result = null
  const hash = {}
  for (let i = 0; i < str.length; i += 1) {
    const key = str[i]
    if (!hash[key]) {
      hash[key] = true
    } else {
      result = key
      break
    }
  }
  return result
}
```

## 106. 找到和为0的两个数

> https://bigfrontend.dev/zh/problem/Find-two-numbers-that-sum-up-to-0

> 使用hash法

```ts
```

## 107. 找到最大的差

> https://bigfrontend.dev/zh/problem/Find-the-largest-difference

## 108. 用队列(Queue)实现栈(Stack)

> https://bigfrontend.dev/zh/problem/Implement-a-Stack-by-using-Queue

## 109. 实现`Math.pow()`

> https://bigfrontend.dev/zh/problem/implement-Math-pow
## 110. 二叉树的序列化和反序列化

> https://bigfrontend.dev/zh/problem/serialize-and-deserialize-binary-tree

```ts
// This is the class for the node
// you can use this directly as it is bundled with your code

// class Node {
//   value: number
//   left: null | Node
//   right: null | Node
//   constructor(val) {
//     this.value = val
//     this.left = null
//     this.right = null
//   }
// }

/**
 * @param {Node} root
 * @return {string}
 */
function serialize(root) {
  // your code here
}

/**
 * @param {string} str
 * @return {Node}
 */
function deserialize(str) {
  // your code here
}
```

## 116. 实现Object.is()

> https://bigfrontend.dev/zh/problem/implement-Object.is

> https://medium.com/coding-at-dawn/is-negative-zero-0-a-number-in-javascript-c62739f80114

```ts
/**
 * @param {any} a
 * @param {any} b
 * @return {boolean}
 */
function is(a, b) {
  if (typeof a === 'number' && typeof b === 'number') {
    if (isNaN(a) && isNaN(b)) {
      return true
    } else if (a === 0 && b === 0) {
      return 1/a === 1/b
    }
  }
  return a === b
}
```

## 120. 实现`isPrime()`

> https://bigfrontend.dev/zh/problem/isPrime

> 判断是否为质数。质数是指在大于1的自然数中，除了1和它本身以外不再有其他因数的自然数。

```ts
```

## 122. 实现 memoizeOne()

> https://bigfrontend.dev/zh/problem/implement-memoizeOne

```ts
const compare = (oldKey, newKey) => {
  if (Array.isArray(oldKey) && Array.isArray(newKey) && oldKey.length === newKey.length) {
    return oldKey.every((key, i) => key === newKey[i])
  }
  return oldKey === newKey
}

/**
 * @param {Function} func
 * @param {(args: any[], newArgs: any[]) => boolean} [isEqual]
 * @returns {any}
 */
function memoizeOne(func, isEqual = compare) {
  let oldKey = Symbol()
  let catchResult = null
  let that = null
  let isCall = false
  
  return function (...params) {
    if (that !== this) {
      oldKey = Symbol()
      that = this
    } 

    if (isCall && isEqual(oldKey, [...params])) {
      return catchResult
    }

    isCall = true
    oldKey = [...params]
    const result = func.apply(this, [...params])
    catchResult = result
    return result
  }
}
```
## 123. 实现 Promise.prototype.finally()

> https://bigfrontend.dev/zh/problem/implement-Promise-prototype-finally

```ts
/**
 * @param {Promise<any>} promise
 * @param {() => void} onFinally
 * @returns {Promise<any>}
 */
function myFinally(promise, onFinally) {
  return promise.then((res) => {
    return Promise.resolve(onFinally()).then(() => {
      return res
    })
  }).catch((err) => {
    return Promise.resolve(onFinally()).then(() => {
      throw err
    })
  })
}
```

## 125. 实现classNames()

> https://bigfrontend.dev/zh/problem/implement-classnames

```ts
```
## 130. 创建LazyMan()

> https://bigfrontend.dev/zh/problem/create-lazyman

```ts
// interface Laziness {
//   sleep: (time: number) => Laziness
//   sleepFirst: (time: number) => Laziness
//   eat: (food: string) => Laziness
// }

function sleep (time) {
  return new Promise(function (resolve) {
    setTimeout(() => {
      resolve()
    }, time)
  })
}

/**
 * @param {string} name
 * @param {(log: string) => void} logFn
 * @returns {Laziness}
 */
function LazyMan(name, logFn) {

  const queue = [() => {
    logFn(`Hi, I'm ${name}.`)
  }]
  let update = false

  const handleQueue = function () {
    update = true
    if (update) {
      Promise.resolve().then(async function () {
        update = false
        for (let i = 0; i < queue.length; i += 1) {
          await queue[i]()
        }
      })
    }
  }

  const laziness = {
    sleep (time) {
      queue.push(async () => {
        await sleep(time * 1000)
        logFn(time > 1 ? `Wake up after ${time} seconds.` : `Wake up after ${time} second.`)
      })
      if (!update) {
        handleQueue()
      }
      return laziness
    },
    sleepFirst (time) {
      queue.unshift(async () => {
        await sleep(time * 1000)
        logFn(time > 1 ? `Wake up after ${time} seconds.` : `Wake up after ${time} second.`)
      })
      if (!update) {
        handleQueue()
      }
      return laziness
    },
    eat (food) {
      queue.push(() => {
        logFn(`Eat ${food}.`)
      })
      if (!update) {
        handleQueue()
      }
      return laziness
    }
  }

  if (!update) {
    handleQueue()
  }

  return laziness
}
```
## 131. 实现_.chunk()

> https://bigfrontend.dev/zh/problem/implement-lodash-chunk

```ts
/** 
 * @param {any[]} items
 * @param {number} size
 * @returns {any[][]}
 */
function chunk(items, size) {
  if (size === 0 || items.length === 0) {
    return []
  }

  const result = []

  while (items.length) {
    result.push(items.splice(0, size))
  }
  
  return result
}
```


## 134. 实现Cookie

> https://bigfrontend.dev/zh/problem/create-your-own-Cookie
## 135. 给localStorage添加过期时间

> https://bigfrontend.dev/zh/problem/localStorage-with-expiration
## 137. 垂直遍历二叉树

> https://bigfrontend.dev/zh/problem/binary-tree-vertical-traversal

```ts
/**
 * @param {Node} root
 * @returns {number[]}
 */
function traverse(root) {
  let result = []
  const hash = {}
  const helper = (node, offset, fnode, depth) => {
    if (node) {
      result.push({
        value: node.value,
        offset,
        fnode,
        depth
      })
      helper(node.left, offset - 1, node, depth + 1)
      helper(node.right, offset + 1, node, depth + 1)
    }
  }
  
  helper(root, 0, null, 0)

  result.sort((a,b) => {
    if (a.offset !== b.offset) {
      return a.offset - b.offset
    } else if (a.depth !== b.depth) {
      return a.depth - b.depth
    } else {
      return 0
    }
  })
  // 构建hash, 方便查找父级的索引
  result.forEach((item, i) => {
    hash[item.value] = {
      ...item,
      i,
    }
  })
  console.log(hash)
  console.log(result)
  result.sort((a,b) => {
    if (a.offset !== b.offset) {
      return a.offset - b.offset
    } else if (a.depth !== b.depth) {
      return a.depth - b.depth
    } else {
      // 根节点特殊处理
      if (!a.fnode) {
        return -1
      } else if (!b.fnode) {
        return 1
      } else {
        const aFnodeIndex = hash[a.fnode.value].i
        const bFnodeIndex = hash[b.fnode.value].i
        return aFnodeIndex - bFnodeIndex
      }
    }
  })
  
  return result.map(item => item.value)
}
```
## 138. 已排序数组的交集

> https://bigfrontend.dev/zh/problem/intersection-of-two0-sorted-Arrays

使用hash的方法：

```ts
/**
 * @param {number[]} arr1 - integers
 * @param {number[]} arr2 - integers
 * @returns {number[]}
 */
function intersect(arr1, arr2) {
  const hash = {}
  const result = []
  
  for (let i = 0; i < arr1.length; i += 1) {
    const key = arr1[i]
    if (!hash[key]) {
      hash[key] = 1
    } else {
      hash[key] += 1
    }
  }

  for (let i = 0; i < arr2.length; i += 1) {
    const key = arr2[i]
    if (hash[key]) {
      hash[key] -= 1
      result.push(key)
    }
  }

  return result
}
```

使用双指针:

```ts
/**
 * @param {number[]} arr1 - integers
 * @param {number[]} arr2 - integers
 * @returns {number[]}
 */
function intersect(arr1, arr2) {
  const result = []
  let pointer1 = 0
  let pointer2 = 0
  
  while (pointer1 < arr1.length && pointer2 < arr2.length) {
    if (arr1[pointer1] === arr2[pointer2]) {
      result.push(arr1[pointer1])
      pointer1 += 1
      pointer2 += 1
    } else if (arr1[pointer1] > arr2[pointer2]) {
      pointer2 += 1
    } else if (arr1[pointer1] < arr2[pointer2]) {
      pointer1 += 1
    }
  }
  
  return result
}
```

## 139. 实现_.partial()

> https://bigfrontend.dev/zh/problem/implement-partial
## 143. Virtual DOM IV - JSX 1

> https://bigfrontend.dev/zh/problem/virtual-dom-iv-jsx-1

```ts
```

## 144. 序列化和反序列化JSON不支持的数据类型

> https://bigfrontend.dev/zh/problem/serialize-and-deserialize-data-types-not-supported-in-JSON

## 145. 最多重复出现的字符

> https://bigfrontend.dev/zh/problem/most-frequently-occurring-character

```js
function count(str: string): string | string[] {
  const map = {}
  let result = []
  for (let i = 0; i < str.length; i += 1) {
    if (!map[str[i]]) {
      map[str[i]] = 1
    } else {
      map[str[i]] += 1
    }
  }
  const max = Math.max(...Object.values(map))
  for (let key in map) {
    if (map[key] === max) {
      result.push(key)
    }
  }

  return result.length > 1 ? result : result[0]
}
```

## 146. 实现Array.prototype.reduce()

> https://bigfrontend.dev/zh/problem/implement-Array-prototype-reduce

## 😭 147. 取石头

> https://bigfrontend.dev/zh/problem/pickup-the-stones

> 这道题目没有太想明白

```ts
function canWinStonePicking(n) {
  if (n === 0) return null
  if (n === 1) return 'B'
  if (n === 2) return 'A'

  const firstMove = new Map([
    [1, false],
    [2, true]
  ])
  const backhand = new Map([
    [1, true],
    [2, false]
  ])

  for (let i = 3; i <= n; i += 1) {
    firstMove.set(i, (backhand.get(i-2) || backhand.get(i-1)))
    backhand.set(i, (firstMove.get(i-2) && firstMove.get(i-1)))
  }

  return firstMove.get(n) ? 'A' : backhand.get(n) ? 'B' : null
}
```

## 148. 创建一个counter对象

> https://bigfrontend.dev/zh/problem/create-a-counter-object

```ts
function createCounter() {
  const obj = { _count: 0 }
  return Object.defineProperties(obj, {
    count: {
      get () {
        const r = obj._count
        obj._count += 1
        return r
      }
    }
  })
}
```

## 149. interpolation

> https://bigfrontend.dev/zh/problem/interpolation

```ts
function t(translation, data = {}) {
  return translation.replace(/{{(.*?)}}/g, (_, key) => data[key] || '')
}
```

## 150. Virtual DOM V - JSX 2

> https://bigfrontend.dev/zh/problem/virtual-dom-v-jsx-2

```ts
```

## 151. 实现Array.prototype.map()

> https://bigfrontend.dev/zh/problem/implement-Array-prototype-map

> Array.prototype.map()可以指定callback执行时的this

```ts
Array.prototype.myMap = function(callback, thisArg) {
  const result = []
  const that = thisArg || this
  this.forEach(function (item, i) {
    result[i] = callback.call(that, item, i, that)
  })
  return result
}
```

## 152. 找到最大的前k个元素

> https://bigfrontend.dev/zh/problem/top-k-elements

> 堆排序，分治

```ts
// 分治
/*
 * @param {number[]} arr
 * @param {number} k
 * @returns {number[]}
 */
function topK(arr, k) {
  if (!arr.length) return []

  let result = []
  let i = 1

  const divideAndConquer = function (arr, base, k) {
    console.log(arr)
    if (arr.length === 1) {
      return arr[0]
    }

    const max = []
    const min = []
    let maxLen = 0
    const referenceValue = arr[0]

    for (let i = 1; i < arr.length; i += 1) {
      if (arr[i] > referenceValue) {
        max.push(arr[i])
      } else {
        min.push(arr[i])
      }
    }
    max.push(referenceValue)

    maxLen = max.length + base

    if (maxLen >= k && max.length) {
      return divideAndConquer(max, base, k)
    } else if (maxLen < k && min.length) {
      return divideAndConquer(min, maxLen, k)
    }
  }

  while (i <= k && i <= arr.length) {
    result.push(divideAndConquer(arr, 0, i))
    i += 1
  }

  return result
}
```

## 153. uglify CSS class names

> https://bigfrontend.dev/zh/problem/unique-class-name

```ts
/**
 * @returns {string}
 */
function getUniqueClassName() {
  const letterSet = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',]
  const letterSetLength = letterSet.length
  let prefix = ''
  let className = letterSet[getUniqueClassName.index]
  // 最后的边界情况
  if (getUniqueClassName.prefix.length === letterSetLength) {
    return ''
  }
  for (let i = 0; i < getUniqueClassName.prefix.length; i += 1) {
    prefix += letterSet[getUniqueClassName.prefix[i]]
  }
  getUniqueClassName.index += 1
  if (getUniqueClassName.index === letterSetLength) {
    getUniqueClassName.index = 0
    if (!getUniqueClassName.prefix.length) {
      getUniqueClassName.prefix.push(0)
    } else {
      if (getUniqueClassName.prefix.every(item => item === letterSetLength - 1)) {
        getUniqueClassName.prefix = getUniqueClassName.prefix.map(() => 0)
        getUniqueClassName.prefix.push(0)
      } else {
        for (let i = getUniqueClassName.prefix.length - 1; i >= 0; i -= 1) {
          if (getUniqueClassName.prefix[i] < letterSetLength - 1) {
            getUniqueClassName.prefix[i] += 1
            break
          }
        }
      }
    }
  }
  return prefix + className;
}

getUniqueClassName.reset = function () {
  getUniqueClassName.prefix = []
  getUniqueClassName.index = 0
}

// 前缀的长度
getUniqueClassName.prefix = []
getUniqueClassName.index = 0
```

## 155. 请实现一个count函数

> https://bigfrontend.dev/zh/problem/count-function

```ts
function count() {
  count.count += 1
  return count.count
}

count.reset = function () {
  count.count = 0
}

count.count = 0
```

## 156. 请实现`_.set()`

> https://bigfrontend.dev/zh/problem/lodash-set

```ts
function set(obj, path, value) {
  // 字符串路径和数组路径统一变为数组路径
  if (typeof path === 'string') {
    path = path.split('.')
  }

  const newPath = []
  const reg = /^([A-Za-z]+)\[([0-9]+)]$/g
  let current = obj
  let laskKey = ''

  const isNumberKey = function (key) {
    // 是否是数字的key
    const isNumberKey = !isNaN(Number(key))
    // 是否为无效的数字key，1 有效的，01 无效的
    return isNumberKey && (Number(key) + '' === key) 
  }

  for (let i = 0; i < path.length; i += 1) {
    if (path[i].includes('[')) {
      const arr = reg.exec(path[i])
      newPath.push(arr[1])
      newPath.push(arr[2])
    } else {
      newPath.push(path[i])
    }
  }

  laskKey = newPath[newPath.length - 1]

  for (let i = 0; i < newPath.length - 1; i += 1) {
    const key = newPath[i]
    const nextKey = newPath[i + 1]
    const v = current[key]
    if (v instanceof Object) {
      current = v
    } else {
      if (isNumberKey(nextKey)) {
        current[key] = []
      } else {
        current[key] = {}
      }
      current = current[key]
    }
  }

  current[laskKey] = value

  return obj
}
```

## 157. semver 比较

> https://bigfrontend.dev/zh/problem/semver-compare

> 版本比较

```ts
/**
 * @param {string} v1
 * @param {string} v2
 * @returns 0 | 1 | -1
 */
function compare(v1, v2) {
  let result = 0
  const reg = /([0-9]+)\.([0-9]+)\.([0-9]+)/
  const v1Arr = []
  const v2Arr = []
  for (let i = 1; i <= 3; i += 1) {
    v1Arr.push(Number(reg.exec(v1)[i]))
    v2Arr.push(Number(reg.exec(v2)[i]))
  }
  for (let i = 0; i < v1Arr.length; i += 1) {
    if (v1Arr[i] > v2Arr[i]) {
      result = 1
      break
    } else if (v1Arr[i] < v2Arr[i]) {
      result = -1
      break
    }
  }
  return result
}
```

## 158. 返回DOM tree中”左边“的元素

> https://bigfrontend.dev/zh/problem/previous-left-sibling

> BFS遍历即可

```ts
/**
 * @param {Element} root
 * @param {Element} target
 * @return {Elemnt | null}
 */
function previousLeftSibling(root, target) {
  let result = null

  const bfs = (nodes) => {
    if (nodes.length) {
      let childrenArr = []
      let index = null
      for (let i = 0; i < nodes.length; i += 1) {
        const children = [...nodes[i].children]
        childrenArr = [...childrenArr, ...children]
      }
      for (let i = 0; i < childrenArr.length; i += 1) {
        if (childrenArr[i] === target) {
          index = i - 1
          if (index !== -1) {
            result = childrenArr[index]
          }
        }
      }
      if (index === null) {
        bfs(childrenArr)
      }
    }
  }

  bfs([root])

  return result
}
```

## 159. 实现promisify()

> https://bigfrontend.dev/zh/problem/promisify

> callback是最后一个参数

```ts
/**
 * @param {(...args) => void} func
 * @returns {(...args) => Promise<any}
 */
function promisify(func) {
  return function(...args) {
    const that = this
    return new Promise(function(resolve, reject) {
      func.apply(that, [...args, function (error, data) {
        if (error) {
          reject(error)
        } else {
          resolve(data)
        }
      }])
    })
  }
}
```

## 162. 请找到未重复出现的整数

> https://bigfrontend.dev/zh/problem/find-the-single-integer

> 利用位运算符

```ts
/**
 * @param {number[]} arr
 * @returns number
 */
function findSingle(arr) {
  let result = arr[0]
  for (let i = 1; i < arr.length; i += 1) {
    result = result ^ arr[i]
  }
  return result
}
```
## 手写ajax

## 手写ajax

## 手写co模块(自执行)
