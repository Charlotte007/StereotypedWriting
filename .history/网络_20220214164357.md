## 😊 为什么 get 请求有长度的限制？

大多数 Web 服务器的限制为 8192 字节 (8 KB)。规范不限制 HTTP Get 请求的长度，但不同的浏览器实现了自己的限制。

可能会头部压缩有关？

## 😊 http 请求有那些字段？

### 请求 Request Headers

- If-Modified-Since: 用于协商缓存，值是之前响应头上的 Last-Modified，在服务器和最后的修改时间 （Modified：调整，稍作修改，配对使用）
- If-None-Match：用于协商缓存，将 ETag 返回给服务端，判断文件是否发生了变化 （配对 Etag 使用，第二次客户端发送第一次请求获取的 Etag）
- Cache-Control：用于强缓存,no-catch(需要判断内容的新鲜度，判断是否使用缓存)，no-store(不使用缓存)

- Content-Type: 内容类型
- Content-Length: 文件的大小
- Host：请求将要发送到的服务器主机名和端口号
- Origin：请求来自于哪个站点。该字段仅指示服务器名称，并不包含任何路径信息（协议+域名+端口号）
- Referer：当前请求页面的来源页面的地址, 可用于处理 CSRF 攻击
- User-Agent：会告诉网站服务器，访问者是通过什么工具来请求的
- Connection：是否是长连接, 决定当前的事务完成后，是否会关闭网络连接。默认 keep-alive（网络连接就是持久的，不会关闭，使得对同一个服务器的请求可以继续在该连接上完成），close 关闭该网络连接，这是 HTTP/1.0 请求的默认值，每个请求都会重新建立 tcp 链接

### 响应 Response Headers

- Last-Modified：用于协商缓存，返回资源最后的修改时间
- ETag：用于协商缓存，ETag 是资源的唯一标识（由服务器生成）
- Expires：用于强缓存 (只存在 响应头中，由服务器设置)
- Cache-Control：用于强缓存 （请求头，响应头中都存在）
- Content-Encoding： 用于对特定媒体类型的数据进行压缩

## 😊 Cache-Control 对比 Expires

- Cache-Control 是 HTTP1.1, Expires 是 HTTP1.0 版本的 （C > E）
- `Cache-Control 的优先级要大于 Expires`，如果包含 Cache-Control 带有 max-age 会忽略 Expires （C > E）
- Cache-Control 和 Expires 设置的值不一样
  - Cache-Control 多个值，主要4种类型值，可缓存性（public，private，no-cache，no-store）, 到期（），重新验证和重新加载（），其他
    - `客户端`可以在HTTP请求中使用的标准 Cache-Control 指令。
      - Cache-Control: max-age=<seconds>
      - Cache-Control: max-stale[=<seconds>]
      - Cache-Control: min-fresh=<seconds>
      - Cache-control: no-cache
      - Cache-control: no-store
      - Cache-control: no-transform
      - Cache-control: only-if-cached
    - `服务器`可以在响应中使用的标准 Cache-Control 指令。
      - Cache-control: must-revalidate （一旦资源过期（比如已经超过max-age），在成功向原始服务器验证之前，缓存不能用该资源响应后续请求。）
      - Cache-control: no-cache
      - Cache-control: no-store
      - Cache-control: no-transform
      - Cache-control: public
      - Cache-control: private
      - Cache-control: proxy-revalidate （与must-revalidate作用相同，但它仅适用于共享缓存（例如代理），并被私有缓存忽略。）
      - Cache-Control: max-age=<seconds>
      - Cache-control: s-maxage=<seconds>
  - Expires 设置的到期时间，可灵活设置，天，小时，分钟，秒等

## 😊 ( If-Modified-Since 和 Last-Modified ) 对比 ( If-None-Match 和 ETag )

- ETag 对于客户端是不透明的，Last-Modified 对于客户端是透明的
- 如果服务器的资源，1s 内修改了两次，If-Modified-Since 会失效。
- 🤔ETag 更消耗性能？

## 😊 WebSocket 使用的是 TCP 还是 UDP 协议？

基于 TCP 协议

## 😊 post 和 get 的区别

1. post 的参数是在 body 中，get 的参数在 url 中
2. post 不能被缓存，get 请求会被缓存
3. get 不应用于会导致副作用的操作，具有幂等性。post 请求用来处理数据。
4. get 请求 url 有长度限制。post 没有限制。
5. post 要比 get 安全。
6. get 的参数只能支持 ASCII 字符集，post 支持任意编码。

## 😊 什么是正向代理？什么是反向代理？

- 正向代理，正向代理是客户端和其他所有服务器（重点：所有）的代理者。比如 VPN，任何可以连接到该代理服务器的软件，就可以通过代理访问任何的其他服务器，然后把数据返回给客户端，这里代理服务器只对客户端负责, 这是正向代理。
  - 客户端 -> 正向代理服务器 -> 使得客户单可访问到代理服务所访问的地址； 1|n ->  1 -> n (放大 < )
- 反向代理，反向代理是客户端和所要代理的服务器之间的代理。如果反向代理了两个服务，那么之后客户端访问这两个服务器的时候，该代理服务器才会给它代理，也就是说，这里的代理服务器只对该代理服务器所代理的服务器负责。这是反向代理。
  - 多个客户端 -> 反向代理服务 -> 目标服务；  n -> 1 -> 1 (收缩 > ) 访问目标，只能通过代理访问 

## 😊 什么是 HSTS?

HSTS(HTTP Strict Transport Security), 强制客户端使用 HTTPS 访问页面，使用原理:

1. 在服务器响应头中添加`Strict-Transport-Security`，可以设置`max-age`
2. 下次如果使用`http`访问，如果`max-age`未过期，客户端会进行内部跳转，可以看到`307 Redirect Internel`的响应码
3. 客户端使用`https`访问页面

## 😊 缓存

### 缓存的命中规则

![rule.png](https://i.loli.net/2021/07/31/v4Z87GEjmN3FwYu.png)

### 说一说强缓存（200）

强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程。强缓存又分为两种 Expires 和 Cache-Control

#### Expires

`HTTP/1.0`, 存在在 HTTP 返回的**响应头**之中。

```shell
# 一天后过期
expires 1d;
```

#### Cache-Control

`HTTP/1.1`, 存在在 HTTP**响应头**以及**请求头**之中。

```shell
# 最大缓存时间3600秒
Cache-Control:max-age=3600
```

##### cache-control: no-cache 和 cache-control: no-store 的区别是什么?

- `no-store`: 永远都不要在客户端存储缓存，每次永远都要从原始服务器获取资源，优先级最高。
- `no-cache`:
  - 如果在`响应头(Response Headers)`之中。可以在客户端存储资源，但每次都「必须去服务器做新鲜度校验」，来决定从服务器获取最新资源 (200) 还是从客户端读取缓存 (304)，即所谓的协商缓存。
  - 如果在`请求头(Request Headers)`之中。告知(代理)服务器不直接使用缓存，要求向原服务器发起请求。

### 说一说协商缓存（304）

协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程。

#### Last-Modified / If-Modified-Since

- Last-Modified, 位于`响应头`上，浏览器在第一次发送请求后，服务器响应会携带上`Last-Modified`字段，返回给客户端, `Last-Modified`携带的是资源最后的修改时间。
- If-Modified-Since, 位于`请求头`上，浏览器在下一次请求的时候，会把之前`Last-Modified`字段的携带上，服务器获取 If-Modified-Since 字段后，会和服务器中该资源的最后修改时间 Last-Modified 对比, 询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。否则读取本地缓存。

#### ETag / If-None-Match

- ETag，位于`响应头`上，ETag 是资源的唯一标识（由服务器生成），会在返会响应的时候，将这个值给浏览器。
- If-None-Match，位于`请求头`上，再次请求的时候，会将 ETag 的值通过 If-None-Match 字段发送给服务器。当服务器发现 If-None-Match 的值与资源的标识一致时，则返回 304，并从本地缓存获取资源，否则重新获取新数据。

> ETag 会消耗服务器资源(因为会有额外的计算)

## 😊 DNS 是什么？

DNS(Domain Name System) 域名解析系统，是因特网上作为域名和 IP 地址相互映射的一个分布式数据库。它的作用非常简单，就是可以根据域名查出对应的 IP 地址。DNS 查询分为递归查询和迭代查询。优先递归查询，然后是迭代查询。

### DNS 解析的过程

1. 首先，会依次检查浏览器缓存，操作系统缓存，本地硬盘的 hosts 文件，路由器缓存，查找对应的 IP 地址，找到就直接返回；否则下一步。
2. 将请求发送给本地 DNS 服务器，在本地 DNS 服务器缓存中查询，如果查找到就直接返回，否则下一步；(1, 2 都是递归查询，这些缓存被称为 DNS 高速缓存)
3. 本地 DNS 服务器向**根域名服务器**发送请求，根域名服务器会告诉本地 DNS 服务器去查询哪个**顶级域名服务器**。
4. 本地域名服务器向**顶级域名服务器**发起查询请求，顶级域名服务器会告诉本地 DNS 服务器，去查找哪个**权限域名服务器**。
5. 本地域名服务器向**权限域名服务器**发起查询请求，权限域名服务器告诉本地域名服务器请求域名所对应的 IP 地址。（3，，4，5 被称为迭代查询）。
6. 最后，本地域名服务器告诉客户端请求域名所对应的 IP 地址。

## 😊 网络协议的分层

![网络分层.png](https://i.loli.net/2021/07/31/xMkrHUsQqfj9Y4F.png)

1. 物理层
2. 数据链路层
3. 网络层
4. 传输层
5. 会话层
6. 表示层
7. 应用层

## 😊 TCP/IP 协议

> TCP/IP 协议不仅仅指的是 TCP 和 IP 两个协议，⽽是指的⼀个由 FTP,SMTP,TCP,UDP,IP,ARP 等等协议构成的协议集合。区分开来说明的话，HTTP协议属7应用层，TCP协议属于4传输层，IP协议为3网络层

`TCP/IP 协议`将应用层、表示层、会话层合并为应用层，物理层和数据链路层合并为网络接口层。

1. 网络接口层(物理层,数据链路层)
2. 网络层
3. 传输层
4. 应用层(会话层，表示层，应用层)

## 😊 说一说三次握手(TCP协议)

![三次握手.png](https://i.loli.net/2021/07/31/67qFZCBjVrw42La.png)

- SYN 表示建立连接
- Seq 序列号 （Sequence Number），每次握手都会生成
- ACK 表示响应，确认号 （Acknowledgment Number），每次使用接收到的 Seq + 1，作为确认号; 最终也是通过 
  - 上一次握手 `发送的Seq + 1` = 这一次握手 `接收到的ACK`
- FIN 表示关闭连接


1. 第一次握手：主机 A 发送位码为`SYN＝1`，随机产生 Seq number=1234567 的数据包到服务器，主机 B 通过`SYN=1`标志物知道，A 要求建立联机；（第一次握手，由浏览器发起，告诉服务器, 客户端要发送请求了）
2. 第二次握手：主机 B 收到请求后，需要再次确认。向主机 A 发送 ack number=(主机 A 的 seq+1)，SYN=1，ACK=1234567 + 1，和随机产生 Seq=7654321 的包；（第二次握手，由服务器发起，告诉浏览器准备好了，你可以发送了）
3. 第三次握手：主机 A 收到后检查 ack number 是否正确，即第一次发送的 seq number+1，以及位码 SYN 是否为 1，若正确，主机 A 会再发送 ack number=(主机 B 的 seq+1)，ack=7654321 + 1，主机 B 收到后确认 Seq 值与 ACK=7654321+ 1 则连接建立成功；（第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧）

🚧 面试回答简洁版本：

1. 客户端发送 SYN=1 和随机数 Seq 的包给服务器。第一次握手，表示客户端需要建立连接。
2. 服务端发送 ACK(ACK 的值是上一次握手 Seq+1)以及 SYN=1, 和随机数 Seq 的包给客户端。第二次握手表示，服务端告诉客户端可以建立连接，你可以发送了。
3. 客户端会检测 `ACK 是否正确（是否等于第一次的 Seq+1）`。如果正确，客户端会发送服务端的 ACK=第二次握手的 Seq+1，`服务端收到后检测 ACK 是否正确(是否等于第二次握手的 Seq+1)`，如果正确表示连接成功。第三次握手表示，客户端告诉服务端我马上准备发送了。

## 😊 🤝 为什么是三次握手?为什么不是四次握手？为什么不是二次握手？

1. 为什么不是二次握手?TCP 是可靠的，需要确认双方的接收和发送能力。第一次握手确认了客户端的发送能力。第二次握手确认了服务端的发送能力，和接收能力。第三次握手确认了客户端的接收能力。
2. 为什么不是四次握手？浪费资源

## 😊 TCP 和 UDP 的区别?

- TCP 需要先建立连接后，才会发送数据。UDP 不需要建立连接，就会发送数据。
- TCP 提供安全性和可靠性。UDP 不保证。
- TCP 是点对点连接的，UDP 一对一，一对多，多对多都可以。
- TCP 传输效率相对较低, 而 UDP 传输效率高。
- TCP 适合用于网页，邮件等; UDP 适合用于视频，语音广播等
- TCP 逻辑通信是全双工的可靠信道，UDP 则是不可靠信道。
- TCP 首部开销大,20 个字节；UDP 首部仅有 8 个字节。

## 😊 什么是单工、半双工和全双工通信？

1. 单工, 只支持数据在一个方向上传输
2. 半双工, 允许数据在两个方向上传输，但是，在某一时刻，只允许数据在一个方向上传输，它实际上是一种切换方向的单工通信。
3. 全双工, 允许数据同时在两个方向上传输，因此，全双工通信是两个单工通信方式的结合。

## 😊 TLS 握手

![TLS.png](https://i.loli.net/2021/08/01/cgzpIy6TdsARqNO.png)

🚧 面试回答简洁版本：

1. 客户端发送支持的加密算法给服务端
2. 服务端返回公钥（用于加密对称加密的密钥）
3. 客户端发送使用公钥加密过的，用于加密对称加密的密钥给服务端。并通知服务端后面的数据段会加密传输。
4. 服务端发送消息，通知客户端后面的数据段会加密传输；TLS 握手结束。

## 😊 Http 报文的组成结构

### 请求报文

![请求报文.png](https://i.loli.net/2021/08/01/Q9Jp3kHI7RBcFXU.png)

- 请求行: 请求方法 | URL | HTTP 协议
- 请求 Header
- 空行(通知服务器以下是请求体)
- 请求体

### 响应报文

![响应报文.png](https://i.loli.net/2021/08/01/z39PpH2KLhyJVkR.png)

- 响应行: HTTP 协议 ｜ 状态码
- 响应 Header
- 空行(通知服务器以下是响应体)
- 响应体

## 😊 Http 协议和 TCP 协议是什么关系呢？

![TCP/IP/HTTP.png](https://i.loli.net/2021/08/01/skY3PjTnVi6Malc.png)

1. DNS 协议用于解析域名
2. Http 协议用于生成请求报文
3. TCP 协议将请求报文按序号分割成多个报文段
4. IP 协议负责搜索和传送报文段
5. TCP 协议，将报文段按顺序合并
6. Http 协议将报文返回给服务度

请求会同样的顺序进行回传

## 😊 TCP 是如何保证可靠性的?

1. TCP 的连接是基于三次握手，保证了连接的可靠性
2. TCP 的断开连接基于四次挥手，保证了断开的可靠性
3. TCP 是可控制，可以控制传输的速度以及重重传。它有数据包校验、ACK 应答、超时重传(发送方)、失序数据重传（接收方）、丢弃重复数据、流量控制（滑动窗口）和拥塞控制等机制。

## 🤔️ 说一说 TCP 超时重传？

![超时重传.png](https://i.loli.net/2021/08/01/sdPwo7LOXQvVp2a.png)

最基本的重传机制，就是超时重传。在发送数据报文时，设定一个定时器，每间隔一段时间，没有收到对方的 ACK 确认应答报文，就会重发该报文。首先了解下什么是 RTT，RTT，一个数据包从发出去到回来的时间，即数据包的一次往返时间。超时重传时间，简称 RTO。一般情况下，RTO 略大于 RTT。

TCP 还拥有快速重传，带选择确认的重传，D-SACK 机制，这里先不复习了。时间有点来不及了。😭

## 🤔️ TCP 报文首部有哪些字段，说说其作用?

> 淦！真有人会问这个吗？

![TCP报文.png](https://i.loli.net/2021/08/01/zmrhukAsdHewUKZ.png)

- 6 位端口号：源端口号，主机该报文段是来自哪里；目标端口号，要传给哪个上层协议或应用程序
- 32 位序号：一次 TCP 通信（从 TCP 连接建立到断开）过程中某一个传输方向上的字节流的每个字节的编号。
- 32 位确认号：用作对另一方发送的 tcp 报文段的响应。其值是收到的 TCP 报文段的序号值加 1。
- 4 位头部长度：表示 tcp 头部有多少个 32bit 字（4 字节）。因为 4 位最大能标识 15，所以 TCP 头部最长是 60 字节。
- 6 位标志位：URG(紧急指针是否有效)，ACk（表示确认号是否有效），PSH（缓冲区尚未填满），RST（表示要求对方重新建立连接），SYN（建立连接消息标志接），FIN（表示告知对方本端要关闭连接了）
- 16 位窗口大小：是 TCP 流量控制的一个手段。这里说的窗口，指的是接收通告窗口。它告诉对方本端的 TCP 接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。
- 16 位校验和：由发送端填充，接收端对 TCP 报文段执行 CRC 算法以检验 TCP 报文段在传输过程中是否损坏。注意，这个校验不仅包括 TCP 头部，也包括数据部分。这也是 TCP 可靠传输的一个重要保障。
- 16 位紧急指针：一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一字节的序号。因此，确切地说，这个字段是紧急指针相对当前序号的偏移，不妨称之为紧急偏移。TCP 的紧急指针是发送端向接收端发送紧急数据的方法。

## 😊 说一说 TCP 滑动窗口？

TCP 发送一个数据，需要收到确认应答，才会发送下一个数据。这样有个缺点，就是效率会比较低。为了解决这个问题，TCP 引入了窗口，它是操作系统开辟的一个缓存空间。窗口大小值表示无需等待确认应答，而可以继续发送数据的最大值。（滑动窗口就是一个缓冲区）

TCP 报文首部有字段，16 位窗口大小，它告诉对方本端的 TCP 接收缓冲区（滑动窗口）还能容纳多少字节的数据，这样对方就可以控制发送数据的速度，从而达到流量控制的目的。

### 发送端的发送窗口

![发送端的发送窗口.png](https://i.loli.net/2021/08/01/qr7W4uahF9QH2ky.png)

### 接收端的接收窗口

![接收端的接收窗口.png](https://i.loli.net/2021/08/01/v87Zu35iIxUSzXq.png)

## 😊 说一说 TCP 拥塞控制？

拥塞控制是作用于网络的，防止过多的数据包注入到网络中，避免出现网络负载过大的情况。

发送方维护一个拥塞窗口 cwnd（congestion window） 的变量，用来估算在一段时间内这条链路可以承载和运输的数据的数量。它大小代表着网络的拥塞程度，并且是动态变化的，如何获取 cwnd 的大小呢？如果出现阻塞，可以逐渐增加 cwnd 的大小。当出现阻塞 cwnd 就应该减小一些。

TCP 通过, 慢启动, 拥塞避免, 拥塞发生, 快速恢复等几种方法实现拥塞控制

### 慢启动

TCP 建立连接后，一开始不要发送大量的数据。由小到大逐渐增加拥塞窗口的大小，如果没有出现丢包，每收到一个 ACK，就将拥塞窗口 cwnd 大小就加 1（单位是 MSS）。每轮次发送窗口增加一倍，呈指数增长，如果出现丢包，拥塞窗口就减半，进入拥塞避免阶段。当 cwnd 增加到一定的阀值（慢启动阀值 ssthresh）后，就会进入拥塞避免的阶段。

### 拥塞避免

慢启动时 cwnd 的增长是指数级的增长，当 cwnd 大于慢启动阀值后，就会进入拥塞避免算法，cwnd 的增长是线性的。当逐渐增大后产生了丢包的情况时，就会产生拥塞发生。

### 拥塞发生

当发生超时重传后，慢启动阀值会被设置为当前的 cwnd/2, cwnd 设置为 1，然后重新进入慢启动过程

## 😊 Connection: keep-alive 做了些什么

响应头上添加`Connection: keep-alive`实现了长连接了。这里的长连接指的是 TCP 的长连接。而不是 HTTP 的连接。TCP 长连接可以复用一个 TCP 连接来发起多次 HTTP 请求。HTTP1.1 默认是长连接，而 HTTP 1.0 协议也支持长连接，但是默认是关闭的。

## 😊 说一说 http 如何实现长连接？在什么时候会超时？

在响应头上添加`Connection: keep-alive`实现了长连接了。

可以在响应头上添加`Keep-Alive: timeout=15, max=100`, 15s 后超时，最多支持 100 个 HTTP 请求

```shell
Keep-Alive: timeout=15, max=100
```

## 😊 说一说四次挥手

![四次挥手.png](https://i.loli.net/2021/08/01/nxqXCi4hp3DgYyH.png)

1. 第一次挥手：客户端发送 FIN=1，以及 Seq 的报文，客户端进入 FIN_WAIT_1 的状态。
2. 第二次挥手：服务端发送 ACK=1, 以及 ack（ack 的值等于第一次挥手客户端传的 seq+1）以及 seq 的报文。服务端进入 CLOSE_WAIT 的状态。
3. 第三次挥手：服务端也准备断开连接了。向客户端发送(FIN=1，ACK1,seq=w,ack=u+1)的报文，服务器端进入 LAST_ACK 状态等待客户端最后一次 ACK。
4. 第四次挥手：客户端接收到服务端关闭的请求，发送 ACK 确认包，并进入 TIME_WAIT 状态，在一段时间后，没有收到服务器端的 ACK 就认为服务端已经关闭了。客户端进入 CLOSED 状态。服务端收到确认包后，关闭进入 CLOSED 状态。

面试回答简洁版本：

1. 客户端发送 FIN，告诉服务端，自己准备关闭。
2. 服务端发送 ACK, 确认了客户端准备关闭的消息。
3. 服务端发送 FIN，告诉客户端，自己准备关闭。
4. 客户端在接收到服务端准备关闭的消息后，发送最后一次确认包。等待一段时间后（两个最大段生命周期），客户端关闭连接。服务端在接收到最后一次确认后，服务端关闭连接。

## 😊 为什么四次挥手的最后一次挥手，客户端需要等待两个 MSL 的时间才会关闭？

1. 第一个 MSL, 是等待确认的 ACK 发送给服务端。
2. 第二个 MSL, 如果服务端没有收到进行重传 FIN 的时间。

## 😊 为什么是四次挥手 🙋？不是三次挥手？不是两次挥手？

![为什么需要四次挥手.png](https://i.loli.net/2021/08/01/TaP9Mk5gFC16c4v.png)

客户端没有消息后，不能确保服务端没有消息发送，所以需要服务端向客户端告知，我没有消息了。

## 😊 说一说 http1.0 和 http1.1 的区别

### 1.0

默认不开启长连接，如果需要开启长连接，需要在响应头添加`Connection: keep-alive`

### 1.1

1. 默认开启了长连接，TCP 连接默认不关闭，可以被多个请求复用。
2. 增加了更多的缓存策略（Cache-Control、Etag/If-None-Match）
3. 新增了新的状态码
4. 引入了管道机制，即在同一个 TCP 连接里面，客户端可以同时发送多个请求。

## 😊 说一说 http2 和 http1.1 的区别

1. http2 采用二进制传输，http1.1 采用文本传输。
   - 帧是 http2 数据通信的最小单位。流是存在于 TCP 连接中的一个虚拟通道。流可以承载双向消息, 每一个流都有一个整数 ID。http2 将请求和响应数据，分割为更小的帧，它们采用二进制编码。
   - http1.1 将请求和响应数据则是以文本换行符分隔。
2. http2 支持多路复用, http1.1 不支持多路复用
   - http1.1 提供了 keep-live，支持一个 tcp 链接，发送多个 http 请求。但是请求必须是有序的，串行的。Chrome 最大支持同一个域名 6 个 TCP 连接，http1.1 实现的是 TCP 的并行。
   - http2，同域名下所有通信都在单个连接上完成，同一个 TCP 连接可以同时存在多个 HTTP 请求。
3. http2 支持服务器主动推送，http1.1 不支持主动推送
   - http2 可以支持主动推送资源给客户端。主动推送也遵守同源策略，服务器不会随便推送第三方资源给客户端。服务端可以主动把 JS 和 CSS 文件推送给客户端，而不需要客户端解析 HTML 时再发送这些请求。
4. http2 支持头部压缩, http1.1 不支持头部压缩
   - http1.1 每一次请求都会携带冗余的头信息，浪费了很多带宽资源。
   - http2 采取了压缩策略, http2 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应发送。
   - 首部表在 http2 的连接存续期内始终存在，由客户端和服务器共同渐进地更新;
   - 每个新的首部键－值对要么被追加到当前表的末尾，要么替换表中之前的值。

## 😊 http1.1 的管道化和 http2 多路复用的区别?

管线化，可以一次性在一个 TCP 连接里，发送多个请求，但是在接收响应的时候，也必须依顺序接收，如果前一个请求遇到了阻塞，后面的请求即使已经处理完毕了，仍然需要等待阻塞的请求处理完毕。

多路复用，即使前一个请求被阻塞，但是不影响后序请求的接收。

## 😊 为什么 http1.1 不能实现多路复用？

http1.1 基于文本传输的，必须按照顺序传输。否则接收后无法正确的拼接。http2 基于帧传输，即使没有按照顺序传送，可以根据帧的首部标示正确的重新组装。

## 😊 什么是队头阻塞？

http 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列（即使是 http1.1 实现了管道化也要求实现串行）。

队列里的请求没有轻重缓急的优先级，只有入队的先后顺序，排在最前面的请求被最优先处理。如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本。这就是队头阻塞。

## 😊 说一说 http3

### http2 的缺点

1. http2 基于 TCL 连接, 所以 7 次握手(TCP3 次握手 + TLS4 次握手)，有很长时间的延迟
2. http2 没有解决队头阻塞的问题

### http3 的改进

1. http3 使用基于 udp 的 QUIC 协议，解决了队头阻塞，不需要“握手”和“挥手。

## 😊 http 中提升传输速率的方式有哪些？

1. DNS Prefetching, DNS 预解析。`<link rel=”dns-prefetch” href=”//fonts.googleapis.com”>`
2. 域名收敛, 将静态资源只放在一个域名下面，可以有效减少 dns 的请求。

## 😊 CDN

### CDN 是什么？

内容分发网络，是建立并覆盖在承载网之上，由分布在不同区域的边缘节点服务器群组成的分布式网络。

### CDN 的工作原理（工作流程）

1. 用户发起 URL 请求
2. DNS 高速缓存进行递归查询，如果有 IP 直接返回(DNS 递归查询)。如果没有则进行 DNS 查询
3. CDN 的 DNS 专用服务器，会让 DNS 区查询，CDN 负载均衡设备的服务器
4. 查询 CDN 负载均衡设备的服务器，CDN 负载均衡设备会返回用户的最佳 IP（DNS 迭代查询）
5. 用户获取到 IP 地址后，访问 IP 地址对应的服务器。
6. 如果该 IP 地址对应的节点已缓存该资源，则会将数据直接返回给用户
7. 如果该 IP 地址对应的节点未缓存该资源，则节点向源站发起对该资源的请求。

### CDN 的优势是什么?

1. 解决因分布，带宽，服务器性能,带来的访问延迟问题。用户可就近取得所需内容。
2. 可以保护网站安全，CDN 的负载均衡和分布式存储技术，可以加强网站的可靠性。

## 😊 https

### 说一说 http 和 https 的区别

![image](https://segmentfault.com/img/remote/1460000017544858?w=543&h=248)

HTTPS 并非是应用层的一种新协议。HTTPS 可以看作 SSL/TLS + HTTP。通过 SSL/TSL 实现加密和解密。HTTP 对加密的内容进行传输

1. HTTPS 需要用到 SSL 证书，而 HTTP 不用。（HTTPS 先和 SSL 通信，再由 SSL 和 TCP 通信了，HTTP 直接和 TCP 通信）
2. HTTPS 是密文传输，HTTP 是明文传输
3. HTTPS 标准端口 443，HTTP 标准端口 80
4. HTTPS 安全，HTTP 不安全
5. HTTPS 通信会消耗更多服务器的 CPU 和内存资源

### 什么是 TLS/SSL

- SSL，即 Secure Sockets Layer（安全套接层协议），是网络通信提供安全及数据完整性的一种安全协议。
- TLS，即 Transport Layer Security(安全传输层协议)，它是 SSL 3.0 的后续版本。

### 说一说 https 工作流程

HTTPS 是在 HTTP 上建立 SSL 加密层，并对传输数据进行加密，是 HTTP 协议的安全版。https 使用**对称加密（用来发送内容）** + **非对称加密（用来传输用于对称加密的密钥）**。使用非对称加密速度比较慢，所以非对称加密仅仅用来传输对称加密的密钥。

![image.png](https://i.loli.net/2021/05/06/wW6BvrTC8Puogj1.png)

1.Client 发起一个 HTTPS 的请求，根据 RFC2818 的规定，Client 默认连接 Server 的 443（默认）端口。
2.Server 把事先配置好的数字证书返回给客户端。
3.Client 验证数字证书（数字证书中包含了公钥）。如果证书不通过，则弹出警告框。
4.Client 生成对称密钥（用于对称加密的密钥），然后用证书的公钥加密这个对称密钥，发给 Server。
5.Server 使用自己的私钥解密这个消息，得到对称密钥。至此，Client 和 Server 双方都持有了相同的对称密钥。
6.Server 使用对称密钥加密“明文内容 A”，发送给 Client。
7.Client 使用对称密钥解密响应的密文，得到“明文内容 A”。
8.Client 再次发起 HTTPS 的请求，使用对称密钥加密请求的“明文内容 B”，然后 Server 使用对称密钥解密密文，得到“明文内容 B”。

### 什么是对称加密？什么是非对称加密？

1. 对称加密，加密和解密使用同一个秘钥
2. 非对称加密，有两个秘钥，公钥和私钥。使用公钥对信息进行加密处理。使用私钥解密。

HTTPS 采用对称加密 + 非对称加密的方式

### 为什么使用对称加密 + 非对称加密的方式？

非对称加密比较慢，对称加密比较快。所以只用非对称加密交换密钥。

### 什么是数字证书？

![数字证书.png](https://i.loli.net/2021/08/02/jvcUHphTl8CrZqI.png)

数字证书包含了:

1. 公钥和个人信息
2. 由公钥和个人信息经过第三方机构形成的数字签名

### 数字证书认证机构认证流程

1. 向第三方机构（CA）提交公钥、组织信息、个人信息(域名)等信息并申请认证。
2. CA 通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等
3. 如信息审核通过，CA 会向申请者签发认证文件-证书。证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构 CA 的信息、有效时间、证书序列号等信息的明文，同时包含一个签名。其中签名的产生算法，首先，使用散列函数计算公开的明文信息的信息摘要，然后，采用 CA 的私钥对信息摘要进行加密，密文即签名;
4. 客户端 Client 向服务器 Server 发出请求时，Server 返回证书文件。
5. 客户端 Client 读取证书中的相关的明文信息，采用相同的散列函数计算得到信息摘要，然后，利用对应 CA 的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性，即服务器的公开密钥是值得信赖的。
6. 客户端还会验证证书相关的域名信息、有效时间等信息; 客户端会内置信任 CA 的证书信息(包含公钥)，如果 CA 不被信任，则找不到对应 CA 的证书，证书也会被判定非法。

## 😊 同源策略和跨域解决方案

### 同源策略

协议/域名/端口，三者有一个不同就是跨域。二级域名之间也存在跨域问题。

对于不同源有如下的限制：

1. cookie、localStorage 和 indexDB 无法读取。
2. ajax 请求不能发送，提示安全问题。

### 跨域方案

1. cors
2. jsonp
3. nginx 转发
4. node 中间层

### JSONP 的原理

JSONP, 利用`script`标签不会跨域实现了跨域请求。JSONP 只支持 GET 请求。

```js
// 首先需要在全局实现handleResponse函数
function handleResponse(response) {
  console.log(
    ` You're at IP address ${response.ip}, which is in ${response.city}, ${response.region_name}`
  );
}

// 发起jsonp请求
let script = document.createElement("script");
script.src = "http://freegeoip.net/json/?callback=handleResponse";
document.body.insertBefore(script, document.body.firstChild);

// 通常script标签会加载如下的内容, 这样就会调用全局下的handleResponse函数
handleResponse("我是数据");
```

### 聊一聊 CORS

CORS 会将请求分为简单请求和非简单请求

#### 简单请求 & 非简单请求

如果请求方法是，HEAD，GET，POST，三种之一。并且头信息不超过 Accept，Accept-Language，Content-Language，Last-Event-ID，Content-Type 就是简单请求

#### 简单请求

对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是在头信息之中，增加一个 Origin 字段。Origin 字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。

如果 Origin 指定的源，不在许可范围内，会返回错误。如果 Origin 指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段：

- Access-Control-Allow-Origin：该字段是必须的。它的值要么是请求时 Origin 字段的值，要么是一个\*，表示接受任意域名的请求。
- Access-Control-Allow-Credentials：该字段可选。它的值是一个布尔值，表示是否允许发送 Cookie。（ajax 要设置 withCredentials 属性，但是此时 Access-Control-Allow-Origin 不能设置为星号）
- Access-Control-Expose-Headers：该字段可选。CORS 请求时，XMLHttpRequest 对象的 getResponseHeader()方法只能拿到 6 个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在 Access-Control-Expose-Headers 里面指定

#### 非简单请求

非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为"预检"请求（preflight）。"预检"请求用的请求方法是 OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是 Origin，表示请求来自哪个源。除了 Origin 字段，"预检"请求的头信息包括两个特殊字段：

- Access-Control-Request-Method：正式请求时用到的方法
- Access-Control-Request-Headers：该字段是一个逗号分隔的字符串，指定浏览器 CORS 请求会额外发送的头信息字段。

## 😊 常见的 http 状态码

- 301 （永久重定向） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置，url 会换成新的。
- 302 （临时重定向） 旧地址仍然可以访问。比如未登录，跳转到登录页。
- 304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。数据从缓存获取。
- 400 （错误请求） 服务器不理解请求的语法。
- 401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。
- 403 （禁止） 服务器拒绝请求。
- 404 （未找到） 服务器找不到请求的资源。
- 405 （方法禁用） 禁用请求中指定的方法。
- 500 （服务器内部错误） 服务器遇到错误，无法完成请求。
- 501 （尚未实施） 服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。
- 502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。
- 503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。
- 504（网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。
- 505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。

### 301 与 302 的区别

1. 对于 301 请求，浏览器是默认给一个很长的缓存。而 302 是不缓存的。
2. 旧地址 A 的资源不可访问了(永久移除), 重定向到网址 B，搜索引擎会抓取网址 B 的内容，同时将网址保存为 B 网址。而 302 是资源仍然可以访问，只是重定向临时从地址 A 转到了 B，此时搜索引擎会抓 B 的内容，但是网址还是 A 的，所以不利于 SEO

### 301 和 302 对 SEO 有什么影响

1. 301 重定向可促进搜索引擎优化效果。
2. 302 重定向可影响搜索引擎优化效果。

## 😊 说一说 http 常用的请求方式

- GET
- POST
- PUT
- DELETE
- HEAD，HEAD 几乎与 GET 相同，但没有响应正文
- OPTIONS

## 😊 接口如何防刷

1. 网关控制流量洪峰，对在一个时间段内出现流量异常，可以拒绝请求。
2. 源 ip 请求个数限制。对请求来源的 ip 请求个数做限制
3. http 请求头信息校验；（例如 host，User-Agent，Referer）
4. 人机验证，验证码，短信验证码，滑动图片形式
5. 拦截器特定信息校验，例如：token

## 😊 webpack 动态加载 js 原理

- 根据 installedChunks 检查是否加载过该 chunk
- 假如没加载过，则发起一个 JSONP 请求去加载 chunk
- 设置一些请求的错误处理，然后返回一个 Promise。

## 😊 扫码登录的原理

1. 网页端请求二维码，服务端生成一个 uuid，会将 uuid 作为 key 存入 redis，同时这个 key 必须设置一个过期时间。同时 uuid 会返回给客户端。客户端会使用 uuid 生成一个二维码，同时客户端会不断的轮训判断是否登录。如果登录了就进行跳转。直到二维码失效。（如果不设置过期时间会一直轮训）
2. 用户打开手机 APP 进行扫描(手机 APP 是已经登录过的)，将手机端的 token 和 uuid 进行提交到服务端。服务器判断 token
   是否合法，如果合法则将 token 作为 value 存到 redis 中。
3. 由于客户端还在不断的轮询，当判断 value 已经存入 redis 后，说明已经成功登录，服务器将 token 回传给 pc 的客户端端。页面跳转就完成了扫码登录。

## 😊 传输图片的过程中如果突然中断，如何在恢复后从之前的中断中恢复传输？

使用断点续传。客户端对文件切片，同时前端或者服务端需要记住已上传的切片。每次上传前，服务端把以上传的切片名返回，前端再跳过这些已经上传切片，这样就实现了“续传”的效果。

## 服务发现为什么用 ip，而不用域名？

## 说一说 web-socket 与 ajax 的区别？
