## 😊 从url输入到页面呈现经历了什么？

1. URL解析，并构造HTTP请求，包含请求头，请求体。
2. 匹配缓存
    1. 根据请求的头的`expires`和`cache-control`判断是否命中强缓存策略。如果命中，直接从缓存获取资源，并不会发送请求。如果没有命中，则进入下一步。
    2. 强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程。根据请求头的`last-modified`和`etag`判断是否命中协商缓存。如果命中，直接从缓存获取资源。如果没有命中，则进入下一步。
3. DNS解析：在发起HTTP请求之前，如果URL不是IP地址是域名，浏览器会发送一个UDP的包给DNS域名解析服务器。将域名解析为IP地址。DNS服务器本身也有IP，电脑的网络设置包含DNS服务器的IP。而DNS的解析分为递归查询和迭代查询。
    - DNS解析的具体流程，请看http章节。
4. 排队，Chrome在同一个域名下要求最多只能有6个TCP连接，超过6个就必须等待。
5. 建立TCP连接，通过"三次握手"与服务器建立TCP连接
6. TLS，TLS握手 （HTTPS需要7次握手，3次TCP握手，4次TLS握手）
    - TLS握手，用来传递公钥，对称密钥，以及传输确认加密传递的信息。（TLS的流程请看http章节）
7. 发送HTTP报文，
    - 包含了：请求行，请求头，空格，请求体（具体的组成请看http章节）
8. 服务器处理请求
9. 服务器响应HTTP请求
    - 包含了：响应行，响应头，空格，响应体（具体的组成请看http章节）
    - 响应完成之后，这时候需要判断请求头或者响应头中的Connection字段是否为`keep-alive`, 如果设置了`keep-alive`则保持这次TCP连接，等待下一次HTTP使用。否则发生四次挥手，断开TCP连接。
10. 浏览器解析，呈现页面

## 😊 浏览器渲染流程

1. 会首先判断Content-Type是否是text/html，如果是开始解析渲染。
2. parsing（解析html）: 解析html文本，将html文本转为流，html文本流通过"HTML文档解析器"和"HTML树构建器"构建为DOM。
    - 对于link标签引入的css文件，不会阻塞html的解析过程，但是读取的时候会阻塞页面渲染
    - 对于没有添加defer, async的script会阻塞html的解析
3. 预加载扫描器，浏览器在构建dom树的时候，占用了主线程。预加载扫描器，将解析可用的内容并请求高优先级资源，如 link、script（添加了async，或者defer） 。浏览器在解析html的同时，会下载他们。
4. style（解析样式）: css样式表经过css解析器生成样式规则模型。根据样式规则模型和默认样式，计算每一个DOM的样式。样式和属性值存储在一个巨大的ComputedStyle对象中。ComputedStyle对象是属性和属性值的映射。ComputedStyle对象中会挂载元素，应对应不同元素的不同样式。
5. layout（布局）: 在计算完DOM的样式之后，需求确定元素的几何形状和元素的坐标，会生成与DOM对应的布局对象(LayoutObject)，形成布局树。
6. compositing update（输入合成）: 对页面进行分层，每个图层被分别绘制。每一个图层都有一个"待显示项目列表"
7. paint(绘制）：目前没有进行真正的绘制，而是将绘制操作（比如根据布局对象（LayoutObject）在指定区域绘制一个红色的矩形。这就是绘制操作。）添加到"待显示项目列表"之中。
8. commit(提交)：更新合成线程图层的状态
9. tiling（切割）: 为了优化下一步的栅格化。将图层分割为图块，图块是栅格化的基本单位。距离视口越近，会优先创建图块优先被栅格化（距离页面顶部越近）。
10. raster(栅格化)：栅格化会将待显示项，转换为颜色值的位图（位图指的是，将图像的信息，以像素为单位记录，记录每一个像素点的颜色信息rgba值）。gpu也可以将待显示项目列表栅格化，我们称为gpu加速。此时位图信息还保存在显存中，没有输出到屏幕上。（位图信息保存在内存中）
12. display: OpenGL调用，绘制像素

## 😊 说一说重绘和回流

> 回流必将引起重绘，而重绘不一定会引起回流。

- 重绘：当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。
- 回流：当Render Tree中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。

## 😊 说一说垃圾回收

### 为什么存在垃圾回收？

V8引擎存在内存的限制。在64位系统上V8最多分配1.4g内存。JS的对象会保存到堆内存上，V8会为每一个对象分配空间，直到堆的大小到达上限。由于JS是单线程的，在进行垃圾回收期间，其他的活动需要暂停。而垃圾回收又是非常耗时的操作，所以V8会限制内存的大小，避免需要回收大量的内存。
### 垃圾回收的策略

1. 标记清理。所有变量都会在内存中被标记。垃圾回收程序会将，所有在当前上下文中的变量，以及被在当前上下文中的变量引用的变量的标记去掉。之后还被标记的变量就是待回收的了。随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存。

2. 引用计数。引用计数会遇到循环引用的问题，导致引用记数永远不会为0。Netscape在4.0版放弃了引用计数的策略。（策略已弃用）
### 新生代 & 老生代

![image.png](https://i.loli.net/2021/04/28/nzq8Aj1csNgPkTm.png)

V8把堆内存分成了两部分进行处理，新生代内存和老生代内存
#### 新生代

新生代，为临时分配的内存。新生代内存在64位系统下，为32mb。新生代内存分为`Form`（正则使用的内容）和`To`（闲置的内存）两部分。垃圾回收的时候，会检查`Form`，没有被回收的变量会被移动到`To`（同时进行了内存空间的重排），而需要清理的直接清理。接着`Form`和`To`会对调，`Form`变为`To`, `To`变为`Form`。然后下次垃圾回收时重复上面的步骤。

> 为什么不直接清除新生代中的内存呢？清理后会产生内存碎片🧩。需要使用上面的步骤，重新排列内存。
#### 老生代

老生代，为常驻内存。如果新生代中的变量如果经过多次回收后依然存在，那么就会被放入到老生代内存中。老生代的内存使用标记清理。（上面有介绍过程👆），标记清理后，V8会对内存空间重排。
### 垃圾回收的优化

1. 如果变量不在使用，可以主动将其设置为null。这被称为解除引用。
2. 使用let和const。因为它们都是块作用域，所以相比于使用var，会更早地让垃圾回收程序介入，尽早回收应该回收的内存。
3. 避免全局变量的使用
4. 避免闭包的过度使用
5. 即时不使用的清理定时器
6. 隐藏类。比如两个变量是同一个类的实例。如果额外的对其中的一个增加属性或者删除属性，将会导致实例不再共享一个隐藏类。
## 😊 from memory cache 与 from disk cache

在Chrome浏览器中的控制台Network中size栏通常会有三种状态:

1.from memory cache
2.from disk cache
3.资源本身的大小(如：1.5k)

他们的区别是什么？

- from memory cache： 资源是直接从`内存`中拿到的，不会请求服务器。当关闭该页面时，此资源就被内存释放掉了，再次重新打开相同页面时不会出现from memory cache的情况。读取速度快
- from disk cache：同上类似，此资源是从`磁盘`当中取出的，也是在已经在之前的某个时间加载过该资源，不会请求服务器但是此资源不会随着该页面的关闭而释放掉，因为是存在硬盘当中的，下次打开仍会from disk cache。读取速度慢
- 大小数值：当`http状态为200`是实实在在从浏览器获取的资源，当http状态为304时该数字是与服务端通信报文的大小，并不是该资源本身的大小，该资源是从本地获取的



对于大文件来说，大概率是不存储在内存中的，反之优先

如果当前系统内存使用率高的话，文件优先存储进硬盘




## 浏览器的架构
## 浏览器的工作原理

## 浏览器有哪些进程？渲染进程中有哪些线程？

## 渲染合成层
