## ⛰️ 错误监控SDK
### ⛰️sdk的一些全局配置

bid是项目的id，uid可以是用户的id（也可以不设置），uuid每一次上报随机参生的

```ts
bid?: string; // 平台分配的应用唯一标识，在创建应用时自动分配的 应用标识 字段
rel?: string; // 前端版本号
uid?: string; // 浏览当前页面的用户唯一标识，推荐设置
sampleRate?: number; // 采样率
silentDev?: boolean; // 是否在开发环境下不发送
// 等等
```
### ⛰️ 对于开发环境的判断

判断url上是否有`local`, `dev`, `localhost`, `0.0.0.0`, `127.0.0.1` 如果有不进行上报

```ts
const allowedHosts: Array<string> = ['local', 'dev', 'localhost', '0.0.0.0', '127.0.0.1'];

export const isDev =
  !!allowedHosts.find(item => hostname.indexOf(item) > -1) || /^http:\/\/(\d{1,3}\.){3}\d{1,3}/.test(origin);
```
### ⛰️ 对于错误的处理
#### ⛰️ RunTimeError

`window.addEventListener('error', this.handleError, false);` 监听运行时js的错误。错误上报的回调添加到queue队列中。。`addEventListener`的第三个参数设置为false，错误需要在冒泡阶段捕获。js资源错误的不会冒泡的。

运行时错误的数据格式

```js
// event是错误监听事件的event

// 格式化错误信息
const matchResult = event.message.match(ERROR_TYPES_RE);
const name = matchResult ? matchResult[1] || 'Error' : 'Error';
const message = matchResult ? matchResult[2] || 'unknown message' : event.message;

const params = {
  type: 'jsError',
  w_name: name, // 错误的名称
  w_msg: message, // 错误的message
  w_file: event.filename, // 出错的文件名
  w_line: event.lineno, // 行
  w_col: event.colno, // 列
  stack: event.error && event.error.stack // 堆栈🙏
};
```

#### ⛰️ UnhandledRejectionError

`window.removeEventListener('unhandledrejection', this.handleError, false);` 监听异步的错误。错误上报的回调添加到queue队列中。。由于时异步错误，所以是没有行，列信息的。

异常错误的数据格式:

```js
const params = {
  type: 'jsError', // 错误的类型
  w_name: 'unhandledrejection', // 统一的w_name
  w_msg: reason instanceof Error ? reason.message : reason,
  stack: reason?.stack // 堆栈信息
};
```
#### ⛰️ ResourceError

`window.removeEventListener('error', this.handleError, true);`, 监听资源加载错误。因为script的error是不会冒泡的。错误上报的回调添加到queue队列中。

ResourceError中会判断target，如果target不是HTMLScriptElement，或者HTMLLinkElement，或者HTMLImageElement则不做处理。避免和RunTimeError重复上报。

资源加载异常的格式:

```js
const _target = {
  outerHTML: target.outerHTML, // 标签的内容, 包括标签
  src, // 标签的src
  tagName
  id: target.id,
  className: target.className,
  XPath: Array.isArray((event as any).path) ? getXPathByPath((event as any).path) : getXPath
  (target) // 获取捕获过程中的所有经过的元素，如果不支持path，则向上递归查找，直到为null
};
```

### ⛰️ 对于性能的处理

- domainLookupStart 域名开始解析时的时间戳
- domainLookupEnd 域名结束结束时的时间戳
- responseEnd 浏览器从服务器、缓存或者本地资源接收响应的最后一个字节或者连接被关闭之时的 Unix毫秒时间戳。
- domInteractive，Document.readyState 改变为'interactive'（可交互的状态）的时间戳
- fetchStart 浏览器已经准备好去使用HTTP请求抓取文档之时时间戳
- loadEventStart load事件被触发之时的时间戳
- loadEventEnd load事件结束的时间戳

```ts
// Performance.timing 只读属性返回一个 PerformanceTiming 对象，这个对象包括了页面相关的性能信息。
let t = performance.timing;
// dns查询的时间
times.w_dns = t.domainLookupEnd - t.domainLookupStart;
// tcp连接的时间
times.w_tcp = t.connectEnd - t.connectStart;
// dom解析的事长
times.w_domparsing = t.domInteractive - t.responseEnd
// 页面可交互的时间
times.w_tti = t.domInteractive - t.fetchStart
// 页面完全加载的时长
times.w_load = t.loadEventStart - t.fetchStart
```

```ts
// register 是获取性能数据的函数
// 如果页面以及加载完成，则立刻获取性能数据，如果没有则在load事件结束后获取
if (document.readyState !== 'complete') {
  // NOTE: passive 忽略 preventDefault()
  window.addEventListener('load', () => setTimeout(register, 0), { passive: true });
} else {
  register();
}
```

获取性能数据后，性能数据也会被push到Queue中




### ⛰️ 对于接口请求速度的监听

重写了原生xhr对象上的open和send方法, send方法记录当前的时间戳，open方法记录了请求方式，请求url，稍后使用。

会在请求完成时，错误时，超时时，将接口请求的数据，push到Queue中

```js
window.XMLHttpRequest.prototype.open = function(...args: any[]) {
  // 保存 method 与 url 后续会用到
  (this as any)._method = args[0];
  (this as any)._url = args[1];

  // @ts-ignore
  self.oldAjaxOpenMethod.call(this, ...args);
};

window.XMLHttpRequest.prototype.send = function(body) {
  const startTime = getTimestamp();
  if (this['addEventListener']) {
    this.addEventListener('timeout', event => _handleEvent(event as any, body, startTime));
    this.addEventListener('error', event => _handleEvent(event as any, body, startTime));
    this.addEventListener('load', event => _handleEvent(event as any, body, startTime));
    this.addEventListener('abort', event => _handleEvent(event as any, body, startTime));
  }

  self.oldAjaxSendMethod.call(this, body);
};
```

### ⛰️ 手动上报接口错误

如果业务方手动catch了错误，可以使用api手动上报

```js
public reportApiError = (params: {
  method: 'GET' | 'HEAD' | 'POST' | 'PUT' | 'DELETE' | 'CONNECT' | 'OPTIONS' | 'TRACE';
  url: string;
  requestBody?: string;
  timestamp?: number;
  status?: number;
  statusText?: string;
  responseBody?: string;
}): void => {
  const p = Object.assign(getBasicInfo(globalConfigs), params, { type: 'api', isAbnormal: true });
  queue.pushTask(() => reporter(p));
};
```
### ⛰️ 对于错误上报的处理
#### ⛰️ reporter

错误上报使用xhr或者`window.navigator.sendBeacon`，如果页面是https, 并且支持`window.navigator.sendBeacon`就使用sendBeacon上报错误。如果是xhr则是post请求。

xhr有可能存在一个问题，就是在关闭浏览器的时候，如果发送ajax异步请求，ajax异步请求有可能会中止。navigator.sendBeacon，用于解决文档卸载时向服务器发送数据的问题。数据异步传输，不影响下一页的加载性能。数据被可靠地发送。

但是不会navigator.sendBeacon不会返回数据发送是否成功的信息。
#### ⛰️ Queue

> 移动端设备使用`visibilitychange`，但是safari不兼容使用beforeunload时间

错误信息都会被push到Queue队列之中。在`visibilitychange`事件，和`beforeunload`事件（兼容safari）。并且`document.visibilityState === 'hidden'`时处理队列。

队列中的数据格式是：

```js
{
  state: {
    time: 当前的时间戳,
    visibilityState: document.visibilityState的状态
  },
  task, // 需要执行的上报任务，是一个函数，就是我们push进去的
  minTaskTime: 默认是0
}
```

每一次push到Queue之后，都会进行处理任务的操作。但是分两种情况

如果当前`document.visibilityState`等于hidden，则在下一次微任务中清空队列。就是使用while循环


如果当前`document.visibilityState`不等于hidden，则在浏览器空闲的时候清空队列。这快就相对来说比较复杂一些。会记录当前的时间戳，然后在下次宏任务（setTimeout(() => , 0)）开始处理队列，处理一次队列，判断当前的用时是否超过了50ms（为模拟requestIdleCallback）。如果超过50ms不处理，等待下一次处理。

如果在50ms内，任务没有处理完成。会开启下一次的任务调度。

#### 为什么在visibilitychange事件中发送信息？

为了避免主线程的阻塞。

## 🚢 社区PC站


## 组件库的开发

### 组件库的打包配置

### 组件库按需引入的原理
### Modal

### Alert
### Tabs
