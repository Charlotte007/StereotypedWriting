## react动画组件

## 错误监控

### 全局配置

### RunTimeError

`window.addEventListener('error', this.handleError, false);` 监听运行时js的错误。错误上报的回调添加到queue队列中。。`addEventListener`的第三个参数设置为false，错误需要在冒泡阶段捕获。js资源错误的不会冒泡的。

运行时错误的数据格式

```js
// event是错误监听事件的event
const matchResult = event.message.match(ERROR_TYPES_RE);
const name = matchResult ? matchResult[1] || 'Error' : 'Error';
const message = matchResult ? matchResult[2] || 'unknown message' : event.message;

const params = {
  type: 'jsError',
  w_name: name,
  w_msg: message,
  w_file: event.filename,
  w_line: event.lineno,
  w_col: event.colno,
  stack: event.error && event.error.stack
};
```

### UnhandledRejectionError

`window.removeEventListener('unhandledrejection', this.handleError, false);` 监听异步的错误。错误上报的回调添加到queue队列中。。由于时异步错误，所以是没有行，列信息的。

异常错误的数据格式:

```js
const params = {
  type: 'jsError', // 错误的类型
  w_name: 'unhandledrejection', // 统一的w_name
  w_msg: reason instanceof Error ? reason.message : reason,
  stack: reason?.stack // 堆栈信息
};
```

### ResourceError

`window.removeEventListener('error', this.handleError, true);`, 监听资源加载错误。因为script的error是不会冒泡的。错误上报的回调添加到queue队列中。

资源加载异常的格式:

```js
const _target = {
  outerHTML: target.outerHTML,
  src,
  tagName,
  id: target.id,
  className: target.className,
  XPath: Array.isArray((event as any).path) ? getXPathByPath((event as any).path) : getXPath
  (target) // 获取捕获过程中的所有经过的元素
};
```
### reporter

错误上报使用xhr或者sendBeacon，如果页面是https, 就使用sendBeacon上报错误

### Queue

> 处理Queue，还会判断剩余时间，这里暂时先不看了

当监控到错误的时候，不会离开上报错误，而是将push到一个队列之中。在`visibilitychange`事件发生时，并且visibilityState时hidden时，会清空队列。

safari页面关闭不会触发visibilitychange事件，所以需要使用beforeunload事件。

### performance

没有使用FCP，TTI，LCP，FID等新的性能标准，而是使用了window.performance.timin的性能标准

```ts
times.w_unload = t.unloadEventEnd - t.unloadEventStart; // 卸载页面的时间
times.w_redirect = t.redirectEnd - t.redirectStart; // 重定向的时间
times.w_appcache = t.domainLookupStart - t.fetchStart; // DNS 缓存时间
times.w_dns = t.domainLookupEnd - t.domainLookupStart; // DNS 查询,解析耗时
times.w_tcp = t.connectEnd - t.connectStart; // TCP链接耗时
times.w_ssl = t.secureConnectionStart !== 0 ? t.connectEnd - t.secureConnectionStart : 0; // SSL 安全连接耗时，只在 HTTPS 下有效
times.w_ttfb = t.responseStart - t.requestStart; // Time to First Byte（TTFB），网络请求耗时
times.w_contentdownload = t.responseEnd - t.responseStart; // 数据传输耗时
times.w_domparsing = t.domInteractive - t.responseEnd; // Dom 解析耗时
times.w_res = t.loadEventStart - t.domContentLoadedEventEnd; // 资源加载耗时
times.w_firstbyte = t.responseStart - t.domainLookupStart; // 首包时间
times.w_tti = t.domInteractive - t.fetchStart; // Time to Interact，首次可交互时间,浏览器完成所有 HTML 解析并且完成 DOM 构建，此时浏览器开始加载资源
times.w_domready = t.domContentLoadedEventEnd - t.fetchStart; // HTML加载完成时间
times.w_load = t.loadEventStart - t.fetchStart; // 页面完全加载时间，load = 首次渲染时间 + DOM 解析耗时 + 同步 JS 执行 + 资源加载耗时
times.w_total = t.loadEventEnd - t.fetchStart; // 总共加载时长
times.w_fpt = t.responseEnd - t.fetchStart; // First Paint Time, 首次渲染时间 / 白屏时间，从请求开始到浏览器开始解析第一批 HTML 文档字节的时间差
```

### 劫持xhr对象

xhr对象send做了一层aop, 会将请求接口的时长做了上报。同样也是push到队列之中。
## PC站


## 组件库的开发

## 少儿编程编辑器
