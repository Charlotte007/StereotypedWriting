## react动画组件

## 错误监控

### 全局配置

bid是项目的id，uid可以是用户的id，uuid是随机的

```ts
bid?: string; // 平台分配的应用唯一标识，在创建应用时自动分配的 应用标识 字段
rel?: string; // 前端版本号
uid?: string; // 浏览当前页面的用户唯一标识，推荐设置
plugins?: Plugins; // 需要开启的插件
sendUrl?: string; // 发送url,开启以后不判断dev环境
sampleRate?: number; // 采样率
spa?: boolean; // 是否为单页面应用，针对单页面应用开启此选项后，可更准确地采集PV
debug?: boolean; // 是否开启debug模式，开启后，将会有更详细的打点过程日志输出，一般用于接入时验证
ignoreScriptError?: boolean; // 是否忽略 JS 异常中的  Script error 错误
metaData?: object; // 可以携带的元数据
setHttpBody?: boolean; // 是否携带HTTP 请求的 body 参数
silentDev?: boolean; // 是否在开发环境下不发送
silentBehavior?: boolean; // 是否需要记录行为
callback?: () => void; // 初始化回调函数
beforeSend?: (logData: any) => boolean; // 日志上报的前置处理，返回 false可阻止日志上报
useFmp?: boolean; // 是否开启 fmp beta 版本， default false
```

### 对于错误的处理
#### RunTimeError

`window.addEventListener('error', this.handleError, false);` 监听运行时js的错误。错误上报的回调添加到queue队列中。。`addEventListener`的第三个参数设置为false，错误需要在冒泡阶段捕获。js资源错误的不会冒泡的。

运行时错误的数据格式

```js
// event是错误监听事件的event
const matchResult = event.message.match(ERROR_TYPES_RE);
const name = matchResult ? matchResult[1] || 'Error' : 'Error';
const message = matchResult ? matchResult[2] || 'unknown message' : event.message;

const params = {
  type: 'jsError',
  w_name: name,
  w_msg: message,
  w_file: event.filename,
  w_line: event.lineno,
  w_col: event.colno,
  stack: event.error && event.error.stack
};
```

#### UnhandledRejectionError

`window.removeEventListener('unhandledrejection', this.handleError, false);` 监听异步的错误。错误上报的回调添加到queue队列中。。由于时异步错误，所以是没有行，列信息的。

异常错误的数据格式:

```js
const params = {
  type: 'jsError', // 错误的类型
  w_name: 'unhandledrejection', // 统一的w_name
  w_msg: reason instanceof Error ? reason.message : reason,
  stack: reason?.stack // 堆栈信息
};
```
#### ResourceError

`window.removeEventListener('error', this.handleError, true);`, 监听资源加载错误。因为script的error是不会冒泡的。错误上报的回调添加到queue队列中。

资源加载异常的格式:

```js
const _target = {
  outerHTML: target.outerHTML,
  src,
  tagName,
  id: target.id,
  className: target.className,
  XPath: Array.isArray((event as any).path) ? getXPathByPath((event as any).path) : getXPath
  (target) // 获取捕获过程中的所有经过的元素
};
```



### 对于错误上报的处理
#### reporter

错误上报使用xhr或者sendBeacon，如果页面是https, 就使用sendBeacon上报错误。sendBeacon不会对上报失败的情况做处理

#### Queue

> 处理Queue，还会判断剩余时间，这里暂时先不看了

当监控到错误的时候，不会离开上报错误，而是将push到一个队列之中。在`visibilitychange`事件发生时，并且visibilityState时hidden时，会清空队列。

safari页面关闭不会触发visibilitychange事件，所以需要使用beforeunload事件。


### 对于性能监听的处理

- domainLookupStart 域名开始解析时的时间戳
- domainLookupEnd 域名结束结束时的时间戳
- responseEnd 浏览器从服务器、缓存或者本地资源接收响应的最后一个字节或者连接被关闭之时的 Unix毫秒时间戳。
- domInteractive，Document.readyState 改变为'interactive'（可交互的状态）的时间戳
- fetchStart 浏览器已经准备好去使用HTTP请求抓取文档之时时间戳
- loadEventStart load事件被触发之时的时间戳
- loadEventEnd load事件结束的时间戳

```ts
// Performance.timing 只读属性返回一个 PerformanceTiming 对象，这个对象包括了页面相关的性能信息。
let t = performance.timing;
// dns查询的时间
times.w_dns = t.domainLookupEnd - t.domainLookupStart;
// tcp连接的时间
times.w_tcp = t.connectEnd - t.connectStart;
// dom解析的事长
times.w_domparsing = t.domInteractive - t.responseEnd
// 页面可交互的时间
times.w_tti = t.domInteractive - t.fetchStart
// 页面完全加载的时长
times.w_load = t.loadEventStart - t.fetchStart
```

```ts
// 如果页面以及加载完成，则立刻获取性能数据，如果没有则在load事件结束后获取
if (document.readyState !== 'complete') {
  // NOTE: passive 忽略 preventDefault()
  window.addEventListener('load', () => setTimeout(register, 0), { passive: true });
} else {
  register();
}
```
### 对于接口请求速度的监听

重写了原生xhr对象上的open和send方法, send方法记录当前的时间戳，open方法记录了请求方式，请求url，稍后使用。

会在请求完成时，错误时，超时时，上报请求的耗时

```js
window.XMLHttpRequest.prototype.open = function(...args: any[]) {
  // 保存 method 与 url 后续会用到
  (this as any)._method = args[0];
  (this as any)._url = args[1];

  // @ts-ignore
  self.oldAjaxOpenMethod.call(this, ...args);
};

window.XMLHttpRequest.prototype.send = function(body) {
  const startTime = getTimestamp();
  if (this['addEventListener']) {
    this.addEventListener('timeout', event => _handleEvent(event as any, body, startTime));
    this.addEventListener('error', event => _handleEvent(event as any, body, startTime));
    this.addEventListener('load', event => _handleEvent(event as any, body, startTime));
    this.addEventListener('abort', event => _handleEvent(event as any, body, startTime));
  }

  self.oldAjaxSendMethod.call(this, body);
};
```

### 接口错误

提供Api，项目方手动上报
## PC站


## 组件库的开发

## 少儿编程编辑器
