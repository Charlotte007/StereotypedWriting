## ⛰️ 错误监控SDK

### ⛰️ shouldReport

是否过滤上报的错误，在将错误push到Queue之前会有一个函数，可以自定义过滤错误。
### ⛰️ sendBeacon的大小限制

sendBeacon的大小限制取决与浏览器的。
### ⛰️ 用户行为的记录以及上报（操作路径）

将点击元素的信息push到records，records最大长度限制是20，如果超出20，就移除第一个。但是后序没有对records队列做处理。

```js
class ClickPlugin implements RigPlugin {
  install() {
    window.addEventListener(
      'click',
      event => {
        const { outerHTML = '', tagName = '', className = '' }: any = event.target || {};
        if (['HTML', 'BODY'].includes(tagName)) {
          return;
        }
        records.push(getListOption('click', { outerHTML, tagName, className }));
      },
      true
    );
  }
  uninstall() {}
}
```
### ⛰️sdk的一些全局配置

bid是项目的id，uid可以是用户的id（也可以不设置），uuid每一次上报随机参生的

```ts
bid?: string; // 平台分配的应用唯一标识，在创建应用时自动分配的 应用标识 字段
rel?: string; // 前端版本号
uid?: string; // 浏览当前页面的用户唯一标识，推荐设置
sampleRate?: number; // 采样率
silentDev?: boolean; // 是否在开发环境下不发送
// 等等
```
### ⛰️ 对于开发环境的判断

判断url上是否有`local`, `dev`, `localhost`, `0.0.0.0`, `127.0.0.1` 如果有不进行上报

```ts
const allowedHosts: Array<string> = ['local', 'dev', 'localhost', '0.0.0.0', '127.0.0.1'];

export const isDev =
  !!allowedHosts.find(item => hostname.indexOf(item) > -1) || /^http:\/\/(\d{1,3}\.){3}\d{1,3}/.test(origin);
```
### ⛰️ 对于错误的处理
#### ⛰️ RunTimeError

`window.addEventListener('error', this.handleError, false);` 监听运行时js的错误。错误上报的回调添加到queue队列中。。`addEventListener`的第三个参数设置为false，错误需要在冒泡阶段捕获。js资源错误的不会冒泡的。

运行时错误的数据格式

```js
// event是错误监听事件的event

// 格式化错误信息
const matchResult = event.message.match(ERROR_TYPES_RE);
const name = matchResult ? matchResult[1] || 'Error' : 'Error';
const message = matchResult ? matchResult[2] || 'unknown message' : event.message;

const params = {
  type: 'jsError',
  w_name: name, // 错误的名称
  w_msg: message, // 错误的message
  w_file: event.filename, // 出错的文件名
  w_line: event.lineno, // 行
  w_col: event.colno, // 列
  stack: event.error && event.error.stack // 堆栈🙏
};
```
#### ⛰️ UnhandledRejectionError

`window.removeEventListener('unhandledrejection', this.handleError, false);` 监听异步的错误。错误上报的回调添加到queue队列中。。由于时异步错误，所以是没有行，列信息的。

异常错误的数据格式:

```js
const params = {
  type: 'jsError', // 错误的类型
  w_name: 'unhandledrejection', // 统一的w_name
  w_msg: reason instanceof Error ? reason.message : reason,
  stack: reason?.stack // 堆栈信息
};
```
#### ⛰️ ResourceError

`window.removeEventListener('error', this.handleError, true);`, 监听资源加载错误。因为script的error是不会冒泡的。错误上报的回调添加到queue队列中。

ResourceError中会判断target，如果target不是HTMLScriptElement，或者HTMLLinkElement，或者HTMLImageElement则不做处理。避免和RunTimeError重复上报。

资源加载异常的格式:

```js
const _target = {
  outerHTML: target.outerHTML, // 标签的内容, 包括标签
  src, // 标签的src
  tagName
  id: target.id,
  className: target.className,
  XPath: Array.isArray((event as any).path) ? getXPathByPath((event as any).path) : getXPath
  (target) // 获取捕获过程中的所有经过的元素，如果不支持path，则向上递归查找，直到为null
};
```
### ⛰️ 对于性能的处理

- domainLookupStart 域名开始解析时的时间戳
- domainLookupEnd 域名结束结束时的时间戳
- responseEnd 浏览器从服务器、缓存或者本地资源接收响应的最后一个字节或者连接被关闭之时的 Unix毫秒时间戳。
- domInteractive，Document.readyState 改变为'interactive'（可交互的状态）的时间戳
- fetchStart 浏览器已经准备好去使用HTTP请求抓取文档之时时间戳
- loadEventStart load事件被触发之时的时间戳
- loadEventEnd load事件结束的时间戳

```ts
// Performance.timing 只读属性返回一个 PerformanceTiming 对象，这个对象包括了页面相关的性能信息。
let t = performance.timing;
// dns查询的时间
times.w_dns = t.domainLookupEnd - t.domainLookupStart;
// tcp连接的时间
times.w_tcp = t.connectEnd - t.connectStart;
// dom解析的事长
times.w_domparsing = t.domInteractive - t.responseEnd
// 页面可交互的时间
times.w_tti = t.domInteractive - t.fetchStart
// 页面完全加载的时长
times.w_load = t.loadEventStart - t.fetchStart
```

```ts
// register 是获取性能数据的函数
// 如果页面以及加载完成，则立刻获取性能数据，如果没有则在load事件结束后获取
if (document.readyState !== 'complete') {
  // NOTE: passive 忽略 preventDefault()
  window.addEventListener('load', () => setTimeout(register, 0), { passive: true });
} else {
  register();
}
```

获取性能数据后，性能数据也会被push到Queue中
### ⛰️ 对于接口请求速度的监听

重写了原生xhr对象上的open和send方法, send方法记录当前的时间戳，open方法记录了请求方式，请求url，稍后使用。

会在请求完成时，错误时，超时时，将接口请求的数据，push到Queue中

```js
window.XMLHttpRequest.prototype.open = function(...args: any[]) {
  // 保存 method 与 url 后续会用到
  (this as any)._method = args[0];
  (this as any)._url = args[1];

  // @ts-ignore
  self.oldAjaxOpenMethod.call(this, ...args);
};

window.XMLHttpRequest.prototype.send = function(body) {
  const startTime = getTimestamp();
  if (this['addEventListener']) {
    this.addEventListener('timeout', event => _handleEvent(event as any, body, startTime));
    this.addEventListener('error', event => _handleEvent(event as any, body, startTime));
    this.addEventListener('load', event => _handleEvent(event as any, body, startTime));
    this.addEventListener('abort', event => _handleEvent(event as any, body, startTime));
  }

  self.oldAjaxSendMethod.call(this, body);
};
```
### ⛰️ 手动上报接口错误

如果业务方手动catch了错误，可以使用api手动上报

```js
public reportApiError = (params: {
  method: 'GET' | 'HEAD' | 'POST' | 'PUT' | 'DELETE' | 'CONNECT' | 'OPTIONS' | 'TRACE';
  url: string;
  requestBody?: string;
  timestamp?: number;
  status?: number;
  statusText?: string;
  responseBody?: string;
}): void => {
  const p = Object.assign(getBasicInfo(globalConfigs), params, { type: 'api', isAbnormal: true });
  queue.pushTask(() => reporter(p));
};
```
### ⛰️ 对于错误上报的处理
#### ⛰️ reporter

错误上报使用xhr或者`window.navigator.sendBeacon`，如果页面是https, 并且支持`window.navigator.sendBeacon`就使用sendBeacon上报错误。如果是xhr则是post请求。

xhr有可能存在一个问题，就是在关闭浏览器的时候，如果发送ajax异步请求，ajax异步请求有可能会中止。navigator.sendBeacon，用于解决文档卸载时向服务器发送数据的问题。数据异步传输，不影响下一页的加载性能。数据被可靠地发送。

但是不会navigator.sendBeacon不会返回数据发送是否成功的信息。
#### ⛰️ Queue

> 移动端设备使用`visibilitychange`，但是safari不兼容使用beforeunload时间

错误信息都会被push到Queue队列之中。在`visibilitychange`事件，和`beforeunload`事件（兼容safari）。并且`document.visibilityState === 'hidden'`时处理队列。

队列中的数据格式是：

```js
{
  state: {
    time: 当前的时间戳,
    visibilityState: document.visibilityState的状态
  },
  task, // 需要执行的上报任务，是一个函数，就是我们push进去的
  minTaskTime: 默认是0
}
```

每一次push到Queue之后，都会进行处理任务的操作。但是分两种情况

如果当前`document.visibilityState`等于hidden，则在下一次微任务中清空队列。就是使用while循环


如果当前`document.visibilityState`不等于hidden，则在浏览器空闲的时候清空队列。这快就相对来说比较复杂一些。会记录当前的时间戳，然后在下次宏任务（setTimeout(() => , 0)）开始处理队列，处理一次队列，判断当前的用时是否超过了50ms（为模拟requestIdleCallback）。如果超过50ms不处理，等待下一次处理。

如果在50ms内，任务没有处理完成。会开启下一次的任务调度。
#### ⛰️ 为什么在visibilitychange事件中发送信息？

为了避免主线程的阻塞。

#### ⛰️ 为什么不用requestIdCallback呢？

兼容性有问题，并且没有垫片, 只能使用setTimeout模拟

### ⛰️ sdk自身错误处理处理？

会对主要的逻辑都使用`try...catch`进行包裹，如果有错误发生目前只会`console.log`。

### 白屏如何处理
## 🚢 社区PC站

社区PC站，并没有使用首屏SSR，之后是CSR。而是全部采用了SSR的方式。BBS路由管理，全部走的后端处理，不存在前端管理Route。所以首屏的数据都是服务端端获取，所以只有注水，没有脱水。

大概的流程，就拿bbs的首页为例：

Beidou的Route会处理访问服务器的url, 交由对应的controller的处理

```ts
router.get('/', controller.bbs.bbsIndex);
```

在controller中会进行请求接口，以及用户的user-agent进行判断，如果是IE浏览器，会进行重定向到老版本。接着就会请求接口（包括了菜单数据的接口, 首页数据的接口，我的关注接口，以及通过cookie判断是否登录isU）并将数据进行组装。然后render对应的page, 并把在controller组装好的数据传递了过去。（egg的特性，通过文件的路径判断）

```ts
public async bbsIndex() {
    const { ctx, service, app } = this;
    const cate = ctx.params && ctx.params[0]
    const menu = await service.common.menu();
    const response_menu = menu.response;
    const cookie = ctx.request.header.cookie

    //旧版IE判断
    const agent = useragent.parse(ctx.req.headers['user-agent']);
  
    let cateId = 0

    if (agent.family === 'IE') {
      if (cateId) {
        ctx.redirect(`/api/v1/dest?id=${cateId}&type=CATEGORY`);
      }
      return;
    }

    let getBBSIndex = null

    getBBSIndex = await service.bbs.getBBSIndex(cateId, cookie);
    let careListInfo = !cate ? await service.bbs.getcareList() : { response: [] }
    let isU = this.ctx.cookies.get('u', { signed: false })

    const response_getBBSIndex = getBBSIndex.response;
    const response_careListInfo = careListInfo.response;

    const vdata = {
      menu: response_menu && response_menu.data,
      env: app.env,
      isLogin: isU ? true : false,
      pageData: response_getBBSIndex && response_getBBSIndex.data,
      careListInfo: response_careListInfo && response_careListInfo.data && response_careListInfo.data.result.data
    };

    await ctx.render('pages/bbsIndex', {
      vdata: vdata,
    });
}
```

静态方法getPartial，返回需要进行局部渲染的React实例Map对象，渲染结果最终会被注入到props中，供 render 方法使用。

getPartial 中返回的 { html: <BBSIndexModule vdata={vdata} />}，React 组件会在渲染中间件中，通过 renderToString api 渲染为字符串，并将结果合并到 html 中。

```ts
import "core-js";
import * as React from "react";
import * as ReactDOM from "react-dom";
import { ViewProps } from "beidou";
import "reset-css";
import "client/style/global.less";
import BBSIndexModule from "client/module/bbs.index";
import Page from "../page";
export default class View extends React.Component<ViewProps> {
  static getPartial(props: { vdata: any }) {
    const { vdata } = props;
    return {
      html: <BBSIndexModule vdata={vdata} />
    };
  }
  render() {
    const { html, helper, vdata } = this.props;
    const { env } = vdata;
    const links: string[] = ['manifest.css', 'bbsIndex.css']
    return (
      <Page
        helper={helper}
        links={links}
        html={html} // 使用getPartial的返回
        vdata={vdata}
        scripts={scripts}
      />
    )
  }
}

if (__CLIENT__) {
  const vdata = window.$$data;
  ReactDOM.hydrate(
    <BBSIndexModule vdata={vdata} />,
    document.getElementById("container")
  );
}

```

__CLIENT__是beidou定义的全局对象，用来判断当前是否是服务端环境还是客户端环境。如何是客户端则进行水和。

BBSIndexModule内部就和普通的React组件一样.

### 遇到那些困难 

### 流式渲染

目前没有在项目上使用到，具体的研究请看react.md上的内容
## 组件库的开发

### 组件库的打包配置

- 对于非按需引入的js文件，由webpack打包，打包到1个js文件中。
- 对于非按需引入的css，使用gulp打包，打包到1个css文件中

- 对于按需引入的js文件，使用gulp打包，按照src目录的层级打包
- 对于按需引入的css文件，使用gulp打包，但是只是做了拷贝操作

webpack没有办法打包es模块，需要使用gulp

### 组件库按需引入的原理

使用babel-import-plugin，配置libraryDirectory，打包的时候，自动修改import的path。

### 对于css的处理

css，使用less，在单独的文件内，做统一的处理

### 滑动穿透的问题如何解决？

在body上设置overflow: hidden。
### Modal




### Alert

### Tabs